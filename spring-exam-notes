Preparation ToDos:
- get all the external links from the certification-questions.com exams and print them
Especially the java doc pages for Spring
- gather all the external links from the "Core Spring 5 certification In Detail" book
and print the most relevant (especially java docs). Check which portions of the 
Spring Reference are most important and print them
- decide on which chapters from "Pivotal Certified Professional Spring Developer Exam" and "Pro Spring 5" should you read
- start revising / re-reading the materials (book chapters, documentation) grouped by topics (e.g. Testing, REST, Spring MVC, Security, AOP and so on) and the notes from this file
- proceed with (re)doing the mock exams without helping by looking at the materials

Annotations can be applied in the following places:
- class-level
- method
- method return type
- method parameter

SPI - Service provider interface
Marker interface - a marker interface is an interface that has no metthods or constants inside it. It provides run-time type information about objects, so the compiler and JVM have additional information about the object.
CLOB - A data type supported by DB/2 and Oracle SQL. it is similar to a BLOB, but includes character encoding, which defines a character set and the way each character is represented
Ant-style wildcards: classpath*:/com/foo/**/sql/*-data.sql
form-backing object - an object used to gather all input from a form

-- Container, DI and Bean Wiring

@Bean is a method-level annotation and cannot be annotated on the class level.
The @Bean annotation can be used inside an @Component-annotated class

@Named - a JSR-330 annotation which is an alternative to Spring's @Component annotation. We can provide a name for the bean using the implicit value argument: @Named("beanName")

XML component scan declaration:
<context:component-scan base-package="org.example.web"/>

<context:annotation-config/> - automatically registers all available bean post-processors like PersistenceAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor and so on.

Here's a valid wildcard syntax that specifies that all classpath resources that match the given prefix will be obtained:
ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/myContext.xml");

@Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired (the configuration class is considered a bean itself). The latter approach allows for explicit, IDE-friendly navigation between @Configuration class methods.

ConfigurableApplicationContext contains the following two methods:
- start() - manually start an application context. This fires up the start of SmartLifecycle (an extension of the Lifecycle interface for those objects that require to be sttartd upon ApplicationContext rfreesh and/or shutdown in a particular order
- close() - Close this application context, destroying all beans in its bean factory
- registerShutdownHook() - Register a shutdown hook with the JVM runtime, closing this context on JVM shutdown unless it has already been closed at that time.
Basically, AbstractApplicationContext#close() will close, or shutdown, the ApplicationContext at the time it is invoked, while AbstractApplicationContext#registerShutdownHook() will close, or shutdown, the ApplicationContext at a later time when the JVM is shutting down for whatever reason. This will be achieved by utilizing the JVM shutdown hook functionality.
The ContextClosedEvent will be fired up after we call close() or the context get closed by a JVM hook after registerShutdownHook has been called

SPI interface to be implemented by most if not all application contexts. Provides facilities to configure an application context in addition to the application context client methods in the ApplicationContext interface.
Configuration and lifecycle methods are encapsulated here to avoid making them obvious to ApplicationContext client code. The present methods should only be used by startup and shutdown code.

In Spring, 5 Auto-wiring modes are supported.

1.no – Default, no auto wiring, set it manually via “ref” attribute
2.byName – Auto wiring by property name. If the name of a bean is same as the name of other bean property, auto wire it.
3.byType – Auto wiring by property data type. If data type of a bean is compatible with the data type of other bean property, auto wire it.
4.constructor – byType mode in constructor argument.
5.autodetect – If a default constructor is found, use “autowired by constructor”; Otherwise, use “autowire by type”.

Autowiring by autodetect uses either of two modes i.e. constructor or byType modes. First it will try to look for valid constructor with arguments, If found the constructor mode is chosen. If there is no constructor defined in bean, or explicit default no-args constructor is present, the autowire byType mode is chosen.

stateless beans: beans that are singleton and are initialized only once. The only state they have is a shared state. These beans are created while the ApplicationContext is being initialized. The SAME bean instance will be returned/injected during the lifetime of this ApplicationContext.

stateful beans: beans that can carry state (instance variables). These are created every time an object is required (prototype-scoped in Spring)

@ImportResource - Like @Import, this annotation provides functionality similar to the <import/> element in Spring XML. It is typically used when designing @Configuration classes to be bootstrapped by an AnnotationConfigApplicationContext, but where some XML functionality such as namespaces is still necessary.
By default, arguments to the value() attribute will be processed using a GroovyBeanDefinitionReader if ending in ".groovy"; otherwise, an XmlBeanDefinitionReader will be used to parse Spring <beans/> XML files. Optionally, the reader() attribute may be declared, allowing the user to choose a custom BeanDefinitionReader implementation.

@Import - Provides functionality equivalent to the <import/> element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register(java.lang.Class<?>...)).

The InitializingBean interface has a method named afterPropertiesSet that allows a bean to perform initialization work after all necessary properties on the bean have been set by the container. The afterPropertiesSet method should have a void and no-argument signature.

The classes constructor is called before assembling the bean.

ResourceLoader - strategy interface for loading resources (e.g. class path or file system resources). An ApplicationContext is required to provide this functionality, plus extended ResourcePatternResolver support.
Bean properties of type Resource and Resource array can be populated from Strings when running in an ApplicationContext, using the particular context's resource loading strategy.

The DisposableBean interface has a single method called destroy(). The destroy() method should have a void and no-argument signature.
Methods annotated with @PreDestroy are called before the destroy() method of the DisposableBean interface is
called.
The @PostConstruct-annotated method is called before the afterPropertiesSet() method of the InitializingBean interface is called.
One way to make the @PostConstruct and @PreDestroy annotations to work, is to register the CommonAnnotationBeanPostProcessor in the Spring context.

@Bean(name={"name1", "name2"}) - this is a valid usage of the @Bean annotation
The @Bean annotations does NOT have an ID attribute.
The @Bean annotation has a value attribute that is an alias for name
The @Bean annotation has no scope attribute. The scope can be set when using @Bean in conjunction with the @Scope annotation

There's a difference between the bean id and bean name. The ID needs to be a valid XML ID. If it contains special characters it won't be a valid bean ID. In such case we can use a bean name. The name also helps in defining aliases for the beans, since it allows specifying multiple identifiers for a given bean.

We can override the default bean scope with the @Scope annotation.
The @Scope annotation has a proxyMode attribute.

Custom bean scopes can be created using the org.springframework.beans.factory.config.Scope interface.
When using @Qualifier annotation the bean name is considered the default qualifier value if not specified otherwise.
@Autowired, @Inject and @Value are implemented using reflection and can be used on private properties.

Configured destruction lifecycle callbacks on prototypes are not called.

If Bean A is a singleton and it has a property bean B which is a non-singleton, every time bean A is acquired by a client, the same instance of bean B is supplied.

Lookup method injection is the ability of the container to override methods on container managed beans, to return the lookup result for another named bean in the container. The lookup typically involves a prototype bean. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method."
Spring does use CGLIB library  (to create proxies) in the implementation of the lookup method injection feature.

 if you are developing a Spring MVC web application you will typically have a root WebApplicationContext loaded via Spring’s ContextLoaderListener and a child WebApplicationContext loaded via Spring’s DispatcherServlet. This results in a parent-child context hierarchy where shared components and infrastructure configuration are declared in the root context and consumed in the child context by web-specific components.

The @Import annotation allows for loading @Bean definitions from another configuration class.
@DependsOn can be used on certain other beans to make sure that other specific beans will be created before the current bean, beyond what the latter's direct dependencies imply

The Spring Expression Language is a separate language from OGNL.
The Spring Expression Language supports regular expressions.

The SpEL expression language supports the following functionality
- Literal expressions
- Boolean and relational operators
- Regular expressions
- Class expressions
- Accessing properties, arrays, lists, maps
- Method invocation
- Relational operators
- Assignment
- Calling constructors
- Bean references
- Array construction
- Inline lists
- Inline maps
- Ternary operator
- Variables
- User defined functions
- Collection projection
- Collection selection
- Templated expressions

It is allowed to have multiple constructor methods in one class where all those constructor methods are:  annotated with @Autowired and marked as non-required. In such case only one of the constructors could be set as required.

If dependencies annotated with @Required are not set a corresponding exception is raised.

If the Autowired annotation is used on well-known dependencies like BeanFactory and ApplicationContext, these dependencies like BeanFactory and ApplicationContext, do not need to be explicitly defined in the context  (e.g. in XML-based configuration).

@Configuration can be annotated on classes only.
Classes annotated with @Configuration don't have to have a constructor with no arguments.
Classes annotated with @Configuration are subclassed at startup-time with CGLIB.
Classes annotated with @Configuration should not be final.

Methods annotated with @PreDestroy are called before the destroy() method of the DisposableBean interface is called.
The @PostConstruct-annotated method is called before the afterPropertiesSet() method of the InitializingBean interface is called.
One way to make the @PostConstruct and @PreDestroy annotations to work, is to register the CommonAnnotationBeanPostProcessor in the Spring context.

The @Qualifier annotation can also be used on types and fields and individual constructor arguments.

Both BeanPostProcessor and BeanFactoryPostProcessor, can control the order in which they execute by implementing the Ordered or PriorityOrdered interface, not just BeanFactoryPostProcessor.
BeanPostProcessor  (not BeanFactoryPostProcessor) operates on bean (or object) instances; that is, it does its work after the container has instantiated a bean instance.
     "BeanFactoryPostProcessor operates on the bean configuration metadata; that is, the Spring IoC container allows a BeanFactoryPostProcessor to read the configuration metadata and potentially change it before the container instantiates any beans other than BeanFactoryPostProcessors."
The BeanFactoryPostProcessor does its work BEFORE the container instantiates any beans.  The BeanPostProcessor does its work AFTER the container has instantiated a bean instance.

The Spring BeanFactory initializes beans in registration order.

When a lazy-initiated bean A is a dependency of non-lazy-initialized singleton bean B, bean A will be non-lazy-initiated.

The following are true about the @Value annotation:
- @Value can be annotated on fields
- @Value can be annotated on methods
- @Value can be annotated on method parameters
- @Value can have expression as its value. Below is an example:
"#{systemProperties.myProperty}"

It is not illegal to define beans with the same ID more than once, but then you get the last bean Spring sees defined (Test 6 from certification-questions.com, question 24) to be injected into the application context.
This is the default behavior the @Order annotation.

@Autowired may also be used for well-known "resolvable dependencies": the BeanFactory interface, the ApplicationContext interface, the ResourceLoader interface, Environment, the ApplicationEventPublisher interface and the MessageSource interface. These interfaces (and their extended interfaces such as ConfigurableApplicationContext or ResourcePatternResolver) will be automatically resolved, with no special setup necessary.

You can register a regular event listener by using the @EventListener annotation.

ApplicationContext interface inherits the following interfaces:
ApplicationEventPublisher, BeanFactory, EnvironmentCapable, HierarchicalBeanFactory, ListableBeanFactory, MessageSource, ResourceLoader, ResourcePatternResolver

Environment objects are used to read value/data from properties files.
@PropertySource annotation contributes to define additional properties.
@Order is used to define sort order for components annotated with this annotation.
Values in application.yaml cannot be loaded with @PropertySource

EnvironmentPostProcessor - Allows for customization of the application's Environment prior to the application context being refreshed. EnvironmentPostProcessor implementations have to be registered in META-INF/spring.factories, using the fully qualified name of this class as the key. EnvironmentPostProcessor processors are encouraged to detect whether Spring's Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation. It is a functional interface.

ContextRefreshedEvent - an event being raised when an application context gets initialized or refreshed. It inherits from java.util.EventObject (all Spring events do), org.springframework.context.ApplicationEvent and org.springframework.context.event.ApplicationContextEvent.

@Order supports the ordering of injected components to a collection.
We can use the Ordered interface to set the highest and lowest precedence:
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/Ordered.html
Ordered.HIGHEST_PRECEDENCE
Ordered.LOWEST_PRECEDENCE

The following two are a way to close an application context, that allows you to listen to an event, so that
you can do some additional actions when the application context is closing:
- AbstractApplicationContext#close
- AbstractApplicationContext#registerShutdownHook

The Spring IoC container is NOT Java EE compliant. Although, Spring supports JSR-330 annotations.

We can annotate a bean with @Lazy to lazily instantiate it.
The @PreDestroy annotated method is called when the application shutdowns gracefully.

@Order is also used for the AspectJ execution order. It means the highest order advice
will run first.

The @Autowired annotation is used to perform type-based injection.
The @Autowired annotation has a 'required' property to indicate if the value being injected
is optional.
When the Autowired annotation is used in a method, the method name may not start with 'set'.
This is just a convention.
When the Autowired annotation is used in a method, the method can have more than one parameters
in it's signature.
When the Autowired annotation is used on an array field or an array method argument 'MyClass[]',
all beans of type MyClass in the Spring context, will be in the array injected.
Types map collections can be autowired as long the key value is a String

The @Profile annotation may be used in any of the following ways:

as a type-level annotation on any class directly or indirectly annotated with @Component, including @Configuration classes
as a meta-annotation, for the purpose of composing custom stereotype annotations
as a method-level annotation on any @Bean method

Methods annotated with @PostConstruct and the afterPropertiesSet() are called after properties of beans are set.
The @Profile annotation could be placed on both classes and methods.
@Profile({exclude="production"}) - this is invalid syntax
@Profile({"!production"}) - this is valid syntax to exclude a profile

Any @Component or @Configuration can be annotated with @Profile to limit when it is loaded.
You can programmatically set active profiles in Spring Boot by calling SpringApplication.setAdditionalProfiles(...) before your application runs. It is also possible to activate profiles by using Spring’s ConfigurableEnvironment interface.

The @PropertySourcesPlaceholderConfigurer:
- is a specialization of PlaceholderConfigurerSupport
- resolves ${...} placeholders within bean definition property values
- is a BeanFactoryPostProcessor
- resolves @Value annotations

The @Values annotation can be used for injecting values into Spring beans' properties by method, property
or constructor level annotations.

Classes annotated with @Configuration should have a constructor with no argument.

Classes annotated with @Configuration are subclassed at runtime by CGLIB. This is why they cannot be final.

The following can be used in a Java-based or annotation based configuration:
@Autowired
@Required
@PreDestroy
@Import

BeanFactoryPostProcessor is used in customizing Spring configuration metadata.

The following apply for @Bean methods that are marked with the java 'static' modifier:
- it is necessary when beans will get initialized early in the container lifecycle
- it avoids triggering other parts of the configuration at that point of definition
- they will never get intercepted by the container, not even within @Configuration classes
- the 'static' modifier allows a method to be called without creating its containing configuration
class as an instance

@Configuration is not needed to do component scanning. @Configuration is needed when using @ComponentScan in java-based configuration; however, @Configuration is not required when using XML-based configuration.

Methods in Java configuration that are annotated with @Autowired cannot return void.

Evaluating a SpEL expression programmatically:
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'"); 
String message = (String) exp.getValue();
The value of the message variable is 'Hello World'.

As of Spring 3.0, a thread scope is available but is not registered by default (org.springframework.context.support.SimpleThreadScope)
As of Spring 4.2, a transactional scope is available as well (org.springframework.transaction.support.SimpleTransactionScope) 
Both of them aren't registered by default.
This is how we can register them:
Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);

Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);

This method is declared on the ConfigurableBeanFactory interface, which is available through the BeanFactory property on most of the concrete ApplicationContext implementations that ship with Spring.

-- AOP

It is good practise to use the least powerful advice type that will solve the problem. For example, using the @After advice for caching returned data from a method would be more preferable than using the @Around advice for the same purpose because calling the proceed() method on the JoinPoint used isn't required here.

AOP is used in the Spring Framework to:
- provide declarative enterprise features. The most important such service is declarative transaction management. The other one is method level security.
- complement OOP design with custom aspects. These can help for logging, caching and profiling before and after method execution

Any advice method may declare, as its first parameter, a parametter of type org.aspectj.lang.JoinPoint (ProceedingJoinPoint is a subclass of JoinPoint). The JoinPoint interface provides a number of useful methods:
- getArgs() - returns the method arguments
- getThis() - returns the proxy object
- getTarget() - returns the target object
- getSignature() - returns a description of the method that is being advised
- toString() - prints description of the method being advised

@EnableLoadTimeWeaving - this annotation allows us to setup a Load-time weaver implementation for load-time AOP weaving, letting ClassTransformer instances be applied only for each class loader and not for each VM.

Spring AOP supports currently only method execution join points.
JDK dynamic proxies are the proxies being used by default by Spring AOP.
JDK dynamic proxies are built into the JDK.
The CGLIB proxy instance is created through Objenesis.

If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used. All of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created.

When two pieces of advice defined in different aspects both need to run at the same join point, by default the order of execution is undefined. Precendence can be specified in the usual for Spring way - by implementing the rg.springframework.core.Ordered interface in the aspect class or annotating it with the @Order annotation. Given two aspects, the aspect returning the lower value from Ordered.getValue() (or the annotation value) has the higher precedence.
When two pieces of advice defined in the same aspect both need to run at the same join point, the ordering is undefined. This cannot be controlled since there is no way to retrieve the declaration order through reflection for javac-compiled classes. A solution would be to merge the logic into a single advice or move the advices into separate aspect and control the flow in the previously mentioned way.

Throws advice can be used with any pointcut.
After returning advice can be used with any pointcut.
The Spring AOP support also uses factory beans under the covers.
In Spring, an Advisor is an aspect that contains only a single advice object associated with a pointcut expression - https://www.mkyong.com/spring/spring-aop-example-pointcut-advisor/
Advisors can be registered as beans (
In Spring AOP, aspects themselves cannot be the targets of advice form other aspects. The @Aspect annotation on a class marks it as an aspect and, hence, exclude it from auto-proxying.

Spring AOP uses JDK dynamic proxies for AOP proxies by default.
Spring AOP proxies that use the standard JDK dynamic proxies canno work with target object that do not expose the target methods through interfaces.
CGLIB is necessary when proxying objects that do not implement any interface.
CGLIB classes are under the org.springframework.cglib package and are included in the spring-core jar

As of Spring 3.2 it is no longer necessary to add CGLIB to your classpath, because CGLIB classes are repackaged under org.springframework and distributed within the spring-core JAR. This is done both for convenience as well as to avoid potential conflicts with other projects that use differing versions of CGLIB.
To be able to do lookup method injection, the class to have a method overriden, must not be 'final', and the method to be overriden cannot be final also. 
The following XML attribute forces the use of CGLIB:
proxy-target-class="true"

The following are true about Spring's proxy feature:
- If a proxied method is called directly by another method from inside the same class, the proxy of that proxied method will not be triggered.
- there is a type of Spring proxy that can replace the object being returned by the method
- There is a type of Spring proxy that can be triggered only if the proxied method throws an exception.
- You can add methods or fields to an advised  (proxied) class.

When the Autowired annotation is used on an array field or an array method argument 'MyClass[]', all beans of type MyClass in the Spring context, will be in the array injected.

Explanation:
It is possible to have @AspectJ support if you are using DTD instead of schema Spring configuration style.
@AspectJ support can be enabled by placing @EnableAspectJAutoProxy on a @Configuration class as shown below:
     @Configuration
     @EnableAspectJAutoProxy
     public class MyAppConfig {}

It is important to note that the @Aspect annotation does not create a bean from the class annotated with it. It needs to have a @Component annotation or an annotation annotated with @Component.

To enable @AspectJ support with XML configuration:
<aop:aspectj-autoproxy/>

After enabling @AspectJ-style AOP annotations the implementation will continue to be Spring AOP-based and therre is no dependency on the AspectJ compiler or weaver. Spring interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut parsing and matching. aspectjweaver.jar needs to be in the classpath to enable @AspectJ-stype in Spring AOP.

join point - a point in the execution of a program such as a method call or an exception thrown
pointcut - an expression that selects one or more join points
advice - code to be executed at a join point
advisor - Group "Advice" and "Pointcut" into a single unit, and pass it to a proxy factory object
aspect - a module that encapsulates a module and advice
weaving - technique by which aspects are combined with main code

An aspect is the class annotated with @Aspect and the advices are methods within that class annotated with the advice annotations (@Before, @After etc)

@AfterReturning(
	pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
	returning="retVal")
public void doAccessCheck(Object retVal) {
	// ...
}
A returning clause also restricts matching to only those method executions that return a value of the specified type (in this case, Object, which matches any return value). is not possible to return a totally different reference when using after returning advice.

Similar semantics are applied in the @AfterThrowing advice:

@AfterThrowing(
	pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
	throwing="ex")
public void doRecoveryActions(DataAccessException ex) {}
The name used in the throwing attribute must correspond to the name of a parameter in the advice method. When a method execution exits by throwing an exception, the exception is passed to the advice method as the corresponding argument value. A throwing clause also restricts matching to only those method executions that throw an exception of the specified type ( DataAccessException, in this case).

You can add methods or fields to an advised (proxied) class.
Spring AOP can use CGLIB proxies on target object that does not implement any interface. Spring AOP cannot use JDK dynamic proxies on target objects that does not implement any interface
In Spring AOP, if the target object implements an interface, it defaults to using the standard JDK dynamic proxies, and this behavior can be overriden to force the use of CGLIB instead.

For AOP, Spring reuses AspectJ's annotations.

Due to the proxy-based nature of Spring's AOP framework, calls within the target object are by definition not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy will be intercepted, and even package-visible methods if necessary.
However, common interactions through proxies should always be designed through public signatures.

If an interception usecase needs to include method calls or even constructors within the target class, consider the use of Spring-driven native AspectJ weaving instead of Spring's proxy-based AOP framework.

Spring AOP also supports an additional Pointcut designator named bean:
bean(idOrNameOfBean)
This pointcut designator lets you limit the matching of join points to a particular named Spring bean or to a set of named Spring beans (when using wildcards).
This pointcut designator is supported only in Spring AOP and not in native AspectJ weaving. It operates at the instance level (building on the Spring beean name concept) rather than at the type level only.

There are two types of point cuts:
- Static pointcuts are based on the method and the target class and cannot take into account the method’s arguments. Static pointcuts suffice — and are best — for most usages. Spring can evaluate a static pointcut only once, when a method is first invoked. After that, there is no need to evaluate the pointcut again with each method invocation.
	- Regular Expression pointcuts - org.springframework.aop.support.JdkRegexpMethodPointcut is a generic regular expression pointcut that uses the regular expression support in the JDK. With the 
	JdkRegexpMethodPointcut class, you can provide a list of pattern strings. If any of these is a match, the pointcut evaluates to true. (So, the result is effectively the union of these pointcuts.)
	<bean id="settersAndAbsquatulatePointcut"
        class="org.springframework.aop.support.JdkRegexpMethodPointcut">
    <property name="patterns">
        <list>
            <value>.*set.*</value>
            <value>.*absquatulate</value>
        </list>
    </property>
	- Attribute-driven static point cut - This uses the values of metadata attributes (typically, source-level metadata).
</bean>
- dynamic pointcuts - they take into account method arguments as well as static information

Any join point (method execution only in Spring AOP) where the target object implements the AccountService interface:
target(com.xyz.service.AccountService)

Any join point (method execution only in Spring AOP) on a Spring bean named tradeService:
bean(tradeService)
bean(*Service) - join poin on all Spring beans whose names/ids end with "Service"

The existing designators naturally fall into one of three groups; kinded, scoping and contextual:
- kinded designators select a particular kind of join point: execution
- scoping designators select a group of join points of interest: within
- contextual match (and optioanlly bind) based on context: this, target and @annotation

Any join point (method execution only in Spring AOP) that takes a single parameter and where the argument passed at runtime is Serializable:
args(java.io.Serializable)
Note that the pointcut given in this example is different from execution(* *(java.io.Serializable)). The args version matches if the argument passed at runtime is Serializable, and the execution version matches if the method signature declares a single parameter of type Serializable.

If the Before advice throws an exception, the join point will not be called.
By not calling the 'proceed()' on the ProceedingJoinPoint parameter of the Around advice method, the join point  (target method) will not be executed.

To enforce the usage of CGLIB in XML-style configuration in Spring AOP:
<aop:config proxy-target-class="true">
    <!-- other beans defined here... -->
</aop:config>

Enable it in AspectJ:
<aop:aspectj-autoproxy proxy-target-class="true"/>

You can use the org.springframework.aop.aspectj.annotation.AspectJProxyFactory class to create a proxy for a target object that is advised by one or more @AspectJ aspects.
// create a factory that can generate a proxy for the given target object
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);
// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager.class);
// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker);
// now get the proxy object...
MyInterfaceType proxy = factory.getProxy();

@Configurable is an annotation that injects dependencies into objects that are not managed by Spring using aspectj libraries. i.e., you still use old way of instantiation with plain new operator to create objects but the spring will take care of injecting the dependencies into that object automatically for you. It will inject the dependencies before the constructor is run if we set the preConstruction attribute to true. It requires aspectj-x.x.x.jar, aspectjrt.jar, aspectjveawer-x.x.x.jar in the classpath for these to run.

To work with AspectJ the following jar must be in the classpath: aspectjweaver.jar
@EnableAspectJAutoProxy - annotation to enable AspectJ on a @Configuration class

It is possible to support arbitrary advice types. The org.springframework.aop.framework.adapter package is an SPI package that lets support for new custom advice types. A custom Advice type must implement the org.aopalliance.aop.Advice marker interface.

Spring is compliant with the AOP Alliance interface for around advice that uses method interception. (org.aopalliance.intercept.MethodInterceptor).
invoke(MethodInvocation invocation)
          Implement this method to perform extra treatments before and after the invocation.

Apart from the special case of introductions, any advisor can be used with any advice. org.springframework.aop.support.DefaultPointcutAdvisor is the most commonly used advisor class. It can be used with a MethodInterceptor, BeforeAdvice, or ThrowsAdvice.

Each AOP advice in Spring is a Spring bean and has its lifecycle.

To make argument values available to the advice body, you can use the binding form of args pointcut designator.
@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
public void validateAccount(Account account) {
    // ...
}
The args(account,..) part of the pointcut expression serves two purposes. First, it restricts matching to only those method executions where the method takes at least one parameter, and the argument passed to that parameter is an instance of Account. Second, it makes the actual Account object available to the advice through the account parameter. Here's another way to achieve this with a pointcut:
@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
    // ...
}

both the advice and the pointcut annotations have an optional "argNames" attribute which can be used to specify the argument names of the annotated method - these argument names are available at runtime. For example:
@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
        argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) { ... }

If the first parameter is of the JoinPoint, ProceedingJoinPoint, or JoinPoint.StaticPart type, you may leave out the name of the parameter from the value of the "argNames" attribute. 
@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
        argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) { ... }

Introductions - (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implemenetation of that interface on behalf of those objects. An introduction is declared using the @DeclareParents annotation. This annotation is used to declare that matching types have a new parent.

You can use @DeclareParents or <aop:declare-parents> to get the mixin behavior. For example,
@DeclareParents(value="service.*", defaultImpl=AuditRecorderDefaultImpl.class)
private AuditRecorder mixin;
will mixin all classes in the service package with the AuditRecorder interface automatically forwarding each method to AuditRecorderDefaultImpl.

Do not be misled by the name of the <aop:aspectj-autoproxy/> element. Using it results in the creation of Spring AOP proxies. The @AspectJ style of aspect declaration is being used here, but the AspectJ runtime is not involved.

-- Spring Web, MVC and Rest

https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments
https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-return-types

Each DispatcherServet has its own WebApplicationContext.

org.springframework.web.context.ContextLoaderListener - Bootstrap listener to start up and shut down Spring's root WebApplicationContext. Simply delegates to ContextLoader as well as to ContextCleanupListener. 
Implementations of ViewResolver and MultipartResolver are registered as Spring beans. They are not detected in the web.xml
BeanNameUrlHandlerMapping is included in the Spring framework and is the default bean if no HandlerMapping bean is registered in the application context.
form-backing object - an object used to gather all input from a form

DispatcherServlet - Spring MVC  designed around the front controller pattern where a central Servlet, the DispatcherServlet, provides a shared algorithm for request processing, while actual work is performed by configurable delegate components.
DispatcherServlet expects a WebApplicationContext (an extension of a plain ApplicationContext) for its own configuration. WebApplicationContext has a link to the ServletContext and the Servlet with which  it is associated. It is also bound to the ServletContext so that applications can use static methods on RequestContextUtils to look up the WebApplicationContext if they need access to it.

Using a Java-based servlet configuration in conjunction with web.xml in Servlet 3.x spec:
import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}

For applications that use a Java-based Spring 3.x servlet configuration we can extend AbstractAnnotationConfigDispatcherServletInitializer abstract class and the following methods:
protected WebApplicationContext	createRootApplicationContext() - Create the "root" application context to be provided to the ContextLoaderListener
protected WebApplicationContext createServletApplicationContext() - Create a servlet application context to be provided to the DispatcherServlet.
protected abstract Class<?>[] 	getRootConfigClasses() - Specify @Configuration and/or @Component classes for the root application context.
protected abstract Class<?>[]	getServletConfigClasses() - Specify @Configuration and/or @Component classes for the Servlet application context.

AbstractDispatcherServletInitializer - Abstract base class that registers a DispatcherServlet in the servlet context. AbstractDispatcherServletInitializer also provides a convenient way to add Filter instances and have them be automatically mapped to the DispatcherServlet:
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {
    @Override
    protected Filter[] getServletFilters() {
        return new Filter[] {
            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
    }
}
The isAsyncSupported protected method of AbstractDispatcherServletInitializer provides a single place to enable async support on the DispatcherServlet and all filters mapped to it. By default, this flag is set to true.
Finally, if you need to further customize the DispatcherServlet itself, you can override the createDispatcherServlet method.

The DispatcherServlet processes requests as follows:

1. The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE key.
2. The locale resolver is bound to the request to let elements in the process resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need the locale resolver.
3. The theme resolver is bound to the request to let elements such as views determine which theme to use. If you do not use themes, you can ignore it.
4. If you specify a multipart file resolver, the request is inspected for multiparts. If multiparts are found, the request is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process. See Multipart Resolver for further information about multipart handling.
5. An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering. Alternatively, for annotated controllers, the response can be rendered (within the HandlerAdapter) instead of returning a view.
6. If a model is returned, the view is rendered. If no model is returned (maybe due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled.

You can customize individual DispatcherServlet instances by adding Servlet initialization parameters (init-param elements) to the Servlet declaration in the web.xml file. The following table lists the supported parameters:
contextClass - Class that implements ConfigurableWebApplicationContext, to be instantiated and locally configured by this Servlet. By default, XmlWebApplicationContext is used.
contextConfigLocation - String that is passed to the context instance (specified by contextClass) to indicate where contexts can be found. The string consists potentially of multiple strings (using a comma as a delimiter) to support multiple contexts. In the case of multiple context locations with beans that are defined twice, the latest location takes precedence.
namespace - Namespace of the WebApplicationContext. Defaults to [servlet-name]-servlet.
throwExceptionIfNoHandlerFound - Whether to throw a NoHandlerFoundException when no handler was found for a request. The exception can then be caught with a HandlerExceptionResolver (for example, by using an @ExceptionHandler controller method) and handled as any others.
By default, this is set to false, in which case the DispatcherServlet sets the response status to 404 (NOT_FOUND) without raising an exception.
Note that, if default servlet handling is also configured, unresolved requests are always forwarded to the default servlet and a 404 is never raised.

The HandlerExceptionResolver beans declared in the WebApplicationContext are used to resolve exceptions thrown during request processing. Those exception resolvers allow customizing the logic to address exceptions.

If an exception occurs during request mapping or is thrown from a request handler (such as a @Controller), the DispatcherServlet delegates to a chain of HandlerExceptionResolver beans to resolve the exception and provide alternative handling, which is typically an error response.
The following are HandlerExceptionResolver implementations:
SimpleMappingExceptionResolver - A mapping between exception class names and error view names. Useful for rendering error pages in a browser application.
DefaultHandlerExceptionResolver - Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. See also alternative ResponseEntityExceptionHandler and REST API exceptions.
ResponseStatusExceptionResolver - Resolves exceptions with the @ResponseStatus annotation and maps them to HTTP status codes based on the value in the annotation.
ExceptionHandlerExceptionResolver - Resolves exceptions by invoking an @ExceptionHandler method in a @Controller or a @ControllerAdvice class. See @ExceptionHandler methods.

HttpServletRequest - subclass of javax.servlet.ServletRequest
org.springframework.web.multipart.MultipartRequest - can be passed as argument to a Spring MVC controller method

@MatrixVariable - for access to name-value pairs in URI path segments.

If a controller method argument is not matched to any of the types described in https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments and is a simple type (org.springframework.beans.BeanUtils#isSimpleProperty), it is resolved as a @RequestParam. Otherwise, it is resolved as a @ModelAttribute.

@ModelAttribute - You can use the @ModelAttribute annotation on a method argument to access an attribute from the model or have it be instantiated if not present. The model attribute is also overlain with values from HTTP Servlet request parameters whose names match to field names. This is referred to as data binding.
using @ModelAttribute is optional. By default, any argument that is not a simple value type (as determined by BeanUtils#isSimpleProperty) and is not resolved by any other argument resolver is treated as if it were annotated with @ModelAttribute.
A parameter annotated with @ModelAttribute is resolved as follows:
- From the model if already added by using Model.
- From the HTTP session by using @SessionAttributes.
- From a URI path variable passed through a Converter (see the next example).
- From the invocation of a default constructor.
- From the invocation of a “primary constructor” with arguments that match to Servlet request parameters. Argument names are determined through JavaBeans @ConstructorProperties or through runtime-retained parameter names in the bytecode.
Data binding can result in errors. By default, a BindException is raised. However, to check for such errors in the controller method, you can add a BindingResult argument immediately next to the @ModelAttribute, as the following example shows:
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return "petForm";
    }
}

You can use the @ModelAttribute annotation:
- On a method argument in @RequestMapping methods to create or access an Object from the model and to bind it to the request through a WebDataBinder.
- As a method-level annotation in @Controller or @ControllerAdvice classes that help to initialize the model prior to any @RequestMapping method invocation.
- On a @RequestMapping method to mark its return value is a model attribute.
A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods in the same controller. A @ModelAttribute method can also be shared across controllers through @ControllerAdvice.
@ModelAttribute methods have flexible method signatures. They support many of the same arguments as @RequestMapping methods, except for @ModelAttribute itself or anything related to the request body.

A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods in the same controller. A @ModelAttribute method can also be shared across controllers through @ControllerAdvice.

Here are 2 @ModelAttribute examples":
@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
When a name is not explicitly specified, a default name is chosen based on the Object type, as explained in the javadoc for org.springframework.core.Conventions. You can always assign an explicit name by using the overloaded addAttribute method or through the name attribute on @ModelAttribute (for a return value).

@SessionAttributes - type-level annotation that is used to store model attributes in the HTTP Servlet session between requests.  It is a type-level annotation that declares the session attributes used by a specific controller. This typically lists the names of model attributes or types of model attributes that should be transparently stored in the session for subsequent requests to access.
A SessionStatus controller argument can be used to clear the value set with @SessionAttributes with the setComplete() method.
@Controller
@SessionAttributes("pet")
public class EditPetForm {
    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) {
	    //...
	    // clears the session variables
            status.setComplete(); 
        }
    }
}

If you need access to pre-existing session attributes that are managed globally (that is, outside the controller — for example, by a filter) and may or may not be present, you can use the @SessionAttribute annotation on a method parameter. For use cases that require adding or removing session attributes, consider injecting org.springframework.web.context.request.WebRequest or javax.servlet.http.HttpSession into the controller method.

Similar to @SessionAttribute, you can use the @RequestAttribute annotations to access pre-existing request attributes created earlier (for example, by a Servlet Filter or HandlerInterceptor).

You can use the @RequestBody annotation to have the request body read and deserialized into an Object through an HttpMessageConverter. The following example uses a @RequestBody argument:
@PostMapping("/accounts")
public void handle(@RequestBody Account account) {}
You can use the Message Converters option of the MVC Config to configure or customize message conversion.

HttpEntity is more or less identical to using @RequestBody but is based on a container object that exposes request headers and body. The following listing shows an example:
@PostMapping("/accounts")
public void handle(HttpEntity<Account> entity) { }

You can use @RequestBody in combination with javax.validation.Valid or Spring’s @Validated annotation, both of which cause Standard Bean Validation to be applied. By default, validation errors cause a MethodArgumentNotValidException, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an Errors or BindingResult argument.

You can use the @ResponseBody annotation on a method to have the return serialized to the response body through an HttpMessageConverter. The following listing shows an example:
@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
}
@ResponseBody is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of @RestController, which is nothing more than a meta-annotation marked with @Controller and @ResponseBody.
ResponseEntity is like @ResponseBody but with status and headers.

Spring MVC provides built-in support for Jackson’s Serialization Views, which allow rendering only a subset of all fields in an Object. To use it with @ResponseBody or ResponseEntity controller methods, you can use Jackson’s @JsonView annotation to activate a serialization view class. Roughly - a POJO class can be declared with public interfaces as subclasses. Methods in the POJO can be annotated with @JsonView(MyJsonView1.class) to mark a particular getter in the POJO to return the field when adding it to a model:
@JsonView allows an array of view classes, but you can specify only one per controller method. If you need to activate multiple views, you can use a composite interface.

model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);

Some annotated controller method arguments that represent String-based request input (such as @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, and @CookieValue) can require type conversion if the argument is not of type String. In such case conversion is applied automatically based on the applied converters. You can customize type conversion through a WebDataBinder (see DataBinder) or by registering Formatters with the FormattingConversionService.

By default, any argument that is a simple value type (as determined by BeanUtils#isSimpleProperty) and is not resolved by any other argument resolver, is treated as if it were annotated with @RequestParam.

@RequestHeader examples:
@RequestHeader("Accept-Encoding") String encoding 
@RequestHeader("Keep-Alive") long keepAlive
When an @RequestHeader annotation is used on a Map<String, String>, MultiValueMap<String, String>, or HttpHeaders argument, the map is populated with all header values.

@CookieValue example:
@CookieValue("JSESSIONID")

Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values separated by comma (for example, /cars;color=red,green;year=2012). Multiple values can also be specified through repeated variable names (for example, color=red;color=green;color=blue).
@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(pathVar="petId", required=false, defaultValue="1") int q) { ... }
@MatrixVariable MultiValueMap<String, String> matrixVars

JDK 8’s java.util.Optional is supported as a method argument in combination with annotations that have a required attribute (for example, @RequestParam, @RequestHeader, and others) and is equivalent to required=false.

Any return value that does not match any of the values in https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-return-types and that is a String or void is treated as a view name (default view name selection through RequestToViewNameTranslator applies), provided it is not a simple type, as determined by BeanUtils#isSimpleProperty. Values that are simple types remain unresolved.

You can form an exception resolver chain by declaring multiple HandlerExceptionResolver beans in your Spring configuration and setting their order properties as needed. The higher the order property, the later the exception resolver is positioned.
The contract of HandlerExceptionResolver specifies that it can return:
- a ModelAndView that points to an error view.
- An empty ModelAndView if the exception was handled within the resolver.
- null if the exception remains unresolved, for subsequent resolvers to try, and, if the exception remains at the end, it is allowed to bubble up to the Servlet container.
The MVC Config automatically declares built-in resolvers for default Spring MVC exceptions, for @ResponseStatus annotated exceptions, and for support of @ExceptionHandler methods. You can customize that list or replace it.

If an exception remains unresolved by any HandlerExceptionResolver and is, therefore, left to propagate or if the response status is set to an error status (that is, 4xx, 5xx), Servlet containers can render a default error page in HTML. To customize the default error page of the container, you can declare an error page mapping in web.xml:
<error-page>
	<location>/error</location>
</error-page>

Given the preceding example, when an exception bubbles up or the response has an error status, the Servlet container makes an ERROR dispatch within the container to the configured URL (for example, /error).
@RestController
public class ErrorController {
    @RequestMapping(path = "/error")
    public Map<String, Object> handle(HttpServletRequest request) {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("status", request.getAttribute("javax.servlet.error.status_code"));
        map.put("reason", request.getAttribute("javax.servlet.error.message"));
        return map;
    }
}

It is also possible to have a context hierarchy where one root WebApplicationContext is shared across multiple DispatcherServlet (or other Servlet) instances, each with its own child WebApplicationContext configuration.
The root WebApplicationContext typically contains infrastructure beans, such as data repositories and business services that need to be shared across multiple Servlet instances. Those beans are effectively inherited and can be overridden (that is, re-declared) in the Servlet-specific child WebApplicationContext, which typically contains beans local to the given Servlet.

If an application context hierarchy is not required, applications may configure a “root” context only and leave the contextConfigLocation Servlet parameter empty.

Those four annotations can be used at method level
@RequestParam
 For access to Servlet request parameters. Parameter values are converted to the declared method argument typ
@RequestHeader
 For access to request headers. Header values are converted to the declared method argument type.
@ModelAttribute
 For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied
@RequestBody
 For access to the HTTP request body. Body content is converted to the declared method argument type using HttpMessageConverters

@RequestMapping annotation can be used without the value property to specify the URI path. In this case the annotated method will be responsible for all URL patterns or sub-patters the controller can handle. It can be used on the type level to define common mappings for all methods in a controller.
By default, Spring MVC performs .* suffix pattern matching so that a controller mapped to /person is also implicitly mapped to /person.*. The file extension is then used to interpret the requested content type to use for the response (that is, instead of the Accept header) — for example, /person.pdf, /person.xml, and others.
To completely disable the use of file extensions, you must set both of the following:
useSuffixPatternMatching(false), see PathMatchConfigurer
favorPathExtension(false), see ContentNegotiationConfigurer

We can specify the content type of the request:
@PostMapping(path = "/pets", consumes = "application/json")
The consumes attribute also supports negation expressions — for example, !text/plain means any content type other than text/plain.
You can declare a shared consumes attribute at the class level. Unlike most other request-mapping attributes, however, when used at the class level, a method-level consumes attribute overrides rather than extends the class-level declaration.
MediaType provides constants for commonly used media types, such as APPLICATION_JSON_VALUE and APPLICATION_XML_VALUE.
MediaType can be used in the "produces" field also for this annotation.
Negated expressions are also supported for the "produces" field also.
@GetMapping(path = "/pets/{petId}", produces = "application/json;charset=UTF-8")
You can narrow request mappings based on request parameter conditions. You can test for the presence of a request parameter (myParam), for the absence of one (!myParam), or for a specific value (myParam=myValue). Here's a few examples for this:
@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")
@GetMapping(path = "/pets/{petId}", headers = "myHeader=myValue") 
@GetMapping(path = "/pets/{petId}", headers = "!myHeader=myValue") - Testing whether myHeader equals myValue.
@GetMapping (and @RequestMapping(method=HttpMethod.GET)) are implicitly mapped to and support HTTP HEAD. An HTTP HEAD request is processed as if it were HTTP GET except that, instead of writing the body, the number of bytes are counted and the Content-Length header is set.

To handle OPTIONS requests we can use @RequestMapping in the following way by setting dispatchOptionsRequest to true:
@RequestMapping(value="/youroptions", method=RequestMethod.OPTIONS)

@ResponseStatus - Marks a method or exception class with the status code() and reason() values that should be returned. It overrides status information set by other means, like ResponseEntiy or "redirect:"

URI variables are automatically converted to the appropriate type, or TypeMismatchException is raised. Simple types (int, long, Date, and so on) are supported by default and you can register support for any other data type with DataBinder.
URI path patterns can also have embedded ${...} placeholders that are resolved on startup by using PropertyPlaceHolderConfigurer against local, system, environment, and other property sources. You can use this, for example, to parameterize a base URL based on some external configuration.

The @RequestParam annotation needs to be used then @PreAuthorize can be used in the class or method level.

Spring MVC uses the HttpMessageConverter interface to convert HTTP requests and responses. 
The spring-web module contains the HttpMessageConverter contract for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for example, in the RestTemplate) and on the server side (for example, in Spring MVC REST controllers).
HttpMessageConverter implementations include: StringHttpMessageConverter (supports all text/* media types), FormHttpMessageConverter (supports application/x-www-form-urlencoded media type), ByteArrayHttpMessageConverter(supports all media types (*/*) and writes a Content-Type of application/octet-stream), MarshallingHttpMessageConverter(supports text/xml and application/xml; requires a marshaller and unmarshaller to be configured), MappingJackson2HttpMessageConverter(uses Jackson's object mapper; handles application/json requests), MappingJackson2XmlHttpMessageConverter(similar to the previous - uses XmlMapper to marshall/unmarshall), SourceHttpMessageConverter(can read and write javax.xml.transform.Source from the HTTP request and response. Only DOMSource, SAXSource, and StreamSource are supported. By default, this converter supports text/xml and application/xml), BufferedImageHttpMessageConverter(can read and write java.awt.image.BufferedImage from the HTTP request and response)

To send multipart data, you need to provide a MultiValueMap<String, Object> whose values may be an Object for part content, a Resource for a file part, or an HttpEntity for part content with headers.

In web.xml you can declare the root application context and declare a DispatcherServlet.
The developer can take entire control over web mvc configuration and disable the default settings in Spring Boot in the following way:
@Configuration
@EnableWebMvc
Doing so leavess all MVC configuration at the hand of the developer. @EnableWebMvc imports DelegatingWebMvcConfiguration which:
- provides default Spring configuration for Spring MVC application
- detects and delegates to WebMvcConfigurer implementations to customize that configuration
For an advanced configuration mode, you can remove @EnableWebMvc and extend directly from DelegatingWebMvcConfiguration instead of implementing WebMvcConfigurer, as the following example shows:
@Configuration
public class WebConfig extends DelegatingWebMvcConfiguration {...}
You can keep existing methods in WebConfig, but you can now also override bean declarations from the base class, and you can still have any number of other WebMvcConfigurer implementations on the classpath.

403 - Forbidden HTTP response

Parameters using the @RequestParam annotation are required by default

The following types can be put in HTTP controller method parameters and Spring will populate these fields with appropriate instances:
- ServletRequest
- HttpSession
- ServletResponse

@RestController is a stereotype annotation that is itself annotated with @Controller and @ResponseBody.  As compared to controllers, classes that are annotated with this, have their @RequestMapping methods assume @ResponseBody semantics by default.

You can use the @ResponseBody annotation on a method to have the return serialized to the response body through an HttpMessageConverter.

org.springframework.http.HttpEntity<T> - Represents an HTTP request or response entity, consisting of headers and body.
org.springframework.http.ResponseEntity - subclass of HttpEntity that adds a HttpStatus code. Used in RestTemplate as well as @Controller methods.

Controllers implemented using annotations do not have to extend specific base classes or implement specific interfaces.
They are testable artifacts because they are simple POJOs.
Controllers implemented with the @Controller class don't have direct dependencies on Servlet or Portlet APIs.

@Controller-annotated classes can easily be configured to have access to Servlet or Portlet facilities  (e.g. to access the current HTTP Session, if any), while remaining testable.

In Spring MVC, some of the values returned by Controller handler methods are: a String, a View or a
ModelAndView

AnnotationConfigWebApplicationContext can be used inside the web.xml when configuring a web application context.  Below is an example.
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>
Below can be used in specifying the @Configuration classes to be considered for a web application context, in web.xml.
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.myPackage.MvcConfig</param-value>
        </init-param> 
The following bean scopes are only valid in the context of a web-aware Spring ApplicationContext:  session, request, application, websocket.  There is no 'web' bean scope out of the box.

The following are valid usages of the @PathVariable annotation:
@RequestMapping(value="/users/{userId}")
public String viewUser(@PathVariable("users") String user, Model m) {...}
@RequestMapping(value="/users/{userId}/addresses/{addressId}")
public String viewUserAddress(@PathVariable String userId, @PathVariable String addressId, Model m) {...}
@RequestMapping(value="/users/{userId}")
public String viewUser(@PathVariable("userId") String personnelId, Model m) {...}
@RequestMapping(value="/users/{userId}")
public String viewUser(@PathVariable String userId, Model m) {...}

The Spring Security Reference says:
     "Spring Security's web infrastructure is based entirely on standard servlet filters. It doesn't use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so it has no strong links to any particular web technology. It deals in HttpServletRequests and HttpServletResponses and doesn't care whether the requests come from a browser, a web service client, an HttpInvoker or an AJAX application."

The DispatcherServlet is an actual Servlet and can be declared in the web.xml. It is thus instantiated by the Servlet container.
The Spring Reference says:
     "In the Web MVC framework, each DispatcherServlet has its own WebApplicationContext, which inherits all the beans already defined in the root WebApplicationContext.  These inherited beans can be overridden in the servlet-specific scope, and you can define new scope-specific beans local to a given Servlet instance."
The Spring Reference also says:
     "The WebApplicationContext is an extension of the plain ApplicationContext that has some extra features necessary for web applications. It differs from a normal ApplicationContext in that it is capable of resolving themes (see Section 16.10, 'Using themes'), and that it knows which Servlet it is associated with (by having a link to the ServletContext)."

DelegatingFilterProxy - it can be declared in the web.xml. It provides the link between the web.xml and the application context. It delegates its filter methods to beans.

By default, DispatcherServlet supports GET, HEAD, POST, PUT, PATCH and DELETE only. DispatcherServlet will process TRACE and OPTIONS with the default HttpServlet behavior unless explicitly told to dispatch those request types as well"

The following can be put on Spring MVC controller method parameters so that Spring will
auto-populate these fields with the appropriate instance:
- ServletRequest
- HttpSession
- ServletResponse

Explanation:
Below is an example.
     &lt;intercept-url pattern="/**" access="authenticated"&gt;&lt;/intercept&gt;
@PathVariable indicates that a method parameter is bound to a URI template variable.
When working with @RestController, @RequestMapping is still needed.
Below is an example.
     @RequestMapping(value="/houses/{houseId}", method=RequestMethod.GET)
     public String findHouse(@PathVariable String houseId, Model model) {

InternalResourceViewResolver - it handles the translation of view names and JSP pages
Idempodent REST operations are those that will produce the same result no matter how many times they are repeated. CONNECT and POST are NOT idempodent REST operations. GET, DELETE, PUT, TRACE, OPTIONS and HEAD are idempodent REST operations.
DispatcherServlet creates an application context, but it is not the root application context.

Spring Web MVC special beans:
HandlerMapping - Map a request to a handler along with a list of interceptors for pre- and post-processing. The mapping is based on some criteria, the details of which vary by HandlerMapping implementation. The two main HandlerMapping implementations are RequestMappingHandlerMapping (which supports @RequestMapping annotated methods) and SimpleUrlHandlerMapping (which maintains explicit registrations of URI path patterns to handlers).
HandlerAdapter - Help the DispatcherServlet to invoke a handler mapped to a request, regardless of how the handler is actually invoked. For example, invoking an annotated controller requires resolving annotations. The main purpose of a HandlerAdapter is to shield the DispatcherServlet from such details.
HandlerExceptionResolver - maps exceptions to views also allowing for more complex exception handling code. Strategy to resolve exceptions, possibly mapping them to handlers, to HTML error views, or other targets.
ViewResolver - resolves logical String-based view names to actual view types with which to render the response
LocaleResolver, LocaleContextResolver - Resolve the Locale a client is using and possibly their time zone, in order to be able to offer internationalized views. 
ThemeResolver - resolves themes your web application can use, for example, to offer personalized layouts
MultipartResolver - Abstraction for parsing a multi-part request (for example, browser form file upload) with the help of some multipart parsing library.
FlashMapResolver - Store and retrieve the “input” and the “output” FlashMap that can be used to pass attributes from one request to another, usually across a redirect.
MessageCodesResolver - strategy interface for building message codes from validation error codes. Used by DataBinder to build the codes list for ObjectErrors and FieldErrors.
Applications can declare the infrastructure beans listed in Special Bean Types that are required to process requests. The DispatcherServlet checks the WebApplicationContext for each special bean. If there are no matching bean types, it falls back on the default types listed in DispatcherServlet.properties.
Applications can declare the infrastructure beans listed in Special Bean Types that are required to process requests. The DispatcherServlet checks the WebApplicationContext for each special bean. If there are no matching bean types, it falls back on the default types listed in DispatcherServlet.properties.

ViewResolver implementations:
AbstractCachingViewResolver - Sub-classes of AbstractCachingViewResolver cache view instances that they resolve. you can use the removeFromCache(String viewName, Locale loc) method to refresh certain view caches at runtime
XmlViewResolver - Implementation of ViewResolver that accepts a configuration file written in XML with the same DTD as Spring’s XML bean factories. The default configuration file is /WEB-INF/views.xml
ResourceBundleViewResolver - Implementation of ViewResolver that uses bean definitions in a ResourceBundle, specified by the bundle base name. For each view it is supposed to resolve, it uses the value of the property [viewname].(class) as the view class and the value of the property [viewname].url as the view URL.
UrlBasedViewResolver - Simple implementation of the ViewResolver interface that affects the direct resolution of logical view names to URLs without an explicit mapping definition.
InternalResourceViewResolver - Convenient subclass of UrlBasedViewResolver that supports InternalResourceView (in effect, Servlets and JSPs) and subclasses such as JstlView and TilesView. You can specify the view class for all views generated by this resolver by using setViewClass(..). 
FreeMarkerViewResolver - Convenient subclass of UrlBasedViewResolver that supports FreeMarkerView and custom subclasses of them.
ContentNegotiatingViewResolver - Implementation of the ViewResolver interface that resolves a view based on the request file name, type (Content-Type header) or Accept header. The ContentNegotiatingViewResolver selects an appropriate View to handle the request by comparing the request media types with the media type (also known as Content-Type) supported by the View associated with each of its ViewResolvers. The first View in the list that has a compatible Content-Type returns the representation to the client. If a compatible view cannot be supplied by the ViewResolver chain, the list of views specified through the DefaultViews property is consulted.

The contract of the single resolveViewName method of ViewResolver specifies that it can return null (it is annotated with @Nullable) to indicate that the view could not be found. However, in the case of JSPs and InternalResourceViewResolver, the only way to figure out if a JSP exists is to perform a dispatch through RequestDispatcher. Therefore, you must always configure an InternalResourceViewResolver to be last in the overall order of view resolvers.

The special redirect: prefix in a view name lets you perform a redirect. The UrlBasedViewResolver (and its subclasses) recognize this as an instruction that a redirect is needed. The rest of the view name is the redirect URL.

The net effect is the same as if the controller had returned a RedirectView, but now the controller itself can operate in terms of logical view names. A logical view name (such as redirect:/myapp/some/resource) redirects relative to the current Servlet context, while a name such as redirect:https://myhost.com/some/arbitrary/path redirects to an absolute URL.
Note that, if a controller method is annotated with the @ResponseStatus, the annotation value takes precedence over the response status set by RedirectView.

You can also use a special forward: prefix for view names that are ultimately resolved by UrlBasedViewResolver and subclasses. This creates an InternalResourceView, which does a RequestDispatcher.forward().

DispatcherServlet lets you automatically resolve messages by using the client’s locale. This is done with LocaleResolver objects. You can enable changing of locales by adding the LocaleChangeInterceptor to one of the HandlerMapping definitions.  It detects a parameter in the request and changes the locale accordingly, calling the setLocale method on the LocaleResolver in the dispatcher’s application context.

To use themes in your web application, you must set up an implementation of the org.springframework.ui.context.ThemeSource interface. The WebApplicationContext interface extends ThemeSource but delegates its responsibilities to a dedicated implementation. By default, the delegate is an org.springframework.ui.context.support.ResourceBundleThemeSource implementation that loads properties files from the root of the classpath. The themeSource bean name is reserved for a theme source bean. A bean with such a name can be registered for a custom bean source.

You can chain view resolvers by declaring more than one resolver bean and, if necessary, by setting the order property to specify ordering. Remember, the higher the order property, the later the view resolver is positioned in the chain.

All HandlerMapping implementations support handler interceptors that are useful when you want to apply specific functionality to certain requests — for example, checking for a principal. Interceptors must implement HandlerInterceptor from the org.springframework.web.servlet package with three methods:
- preHandle(..): Before the actual handler is executed. The preHandle method returns a boolean value. You can use this method to break or continue the processing of the execution chain.
- postHandle(..): After the handler is executed. Note that postHandle is less useful with @ResponseBody and ResponseEntity methods for which the response is written and committed within the HandlerAdapter and before postHandle. That means it is too late to make any changes to the response, such as adding an extra header. For such scenarios, you can implement ResponseBodyAdvice and either declare it as an Controller Advice bean or configure it directly on RequestMappingHandlerAdapter.
- afterCompletion(..): After the complete request has finished

Registering a custom HandlerMapping:
@Configuration
public class MyConfig {
    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) 
            throws NoSuchMethodException {
        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); 
        Method method = UserHandler.class.getMethod("getUser", Long.class); 
        mapping.registerMapping(info, handler, method); 
    }
}

Keep in mind URI templates are automatically encoded. For example:
          restTemplate.getForObject("http://example.com/hotel list", String.class);
          // Results in request to "http://example.com/hotel%20list"
This method getForObject retrieves a representation by doing a GET on the specified URL.
The method getForObject will fail if the 'String.class' is changed to 'Integer.class'.  The return type and the second parameter should be the same. 
The method definition is:
     public &lt;T&gt; T getForObject(java.lang.String url,
                                    java.lang.Class&lt;T&gt; responseType,
                                    java.lang.Object... uriVariables)

Typically @ExceptionHandler, @InitBinder, and @ModelAttribute methods apply within the @Controller class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class annotated with @ControllerAdvice or @RestControllerAdvice.

@ControllerAdvice is annotated with @Component, which means such classes can be registered as Spring beans through component scanning. @RestControllerAdvice is a composed annotation that is annotated with both @ControllerAdvice and @ResponseBody, which essentially means @ExceptionHandler methods are rendered to the response body through message conversion (versus view resolution or template rendering).

On startup, the infrastructure classes for @RequestMapping and @ExceptionHandler methods detect Spring beans annotated with @ControllerAdvice and then apply their methods at runtime. Global @ExceptionHandler methods (from a @ControllerAdvice) are applied after local ones (from the @Controller). By contrast, global @ModelAttribute and @InitBinder methods are applied before local ones.

By default, @ControllerAdvice methods apply to every request (that is, all controllers), but you can narrow that down to a subset of controllers by using attributes on the annotation, as the following example shows:

// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}

@Controller or @ControllerAdvice classes can have @InitBinder methods that initialize instances of WebDataBinder, and those, in turn, can:
- Bind request parameters (that is, form or query data) to a model object.
- Convert String-based request values (such as request parameters, path variables, headers, cookies, and others) to the target type of controller method arguments.
- Format model object values as String values when rendering HTML forms.
@InitBinder methods can register controller-specific java.bean.PropertyEditor or Spring Converter and Formatter components. In addition, you can use the MVC config to register Converter and Formatter types in a globally shared FormattingConversionService.
@InitBinder methods support many of the same arguments that @RequestMapping methods do, except for @ModelAttribute (command object) arguments. Typically, they are declared with a WebDataBinder argument (for registrations) and a void return value.
@Controller
public class FormController {
    @InitBinder 
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }
}

@Controller and @ControllerAdvice classes can have @ExceptionHandler methods to handle exceptions from controller methods, as the following example shows:
@Controller
public class SimpleController {
    @ExceptionHandler
    public ResponseEntity<String> handle(IOException ex) {
    }
}
The exception may match against a top-level exception being propagated (that is, a direct IOException being thrown) or against the immediate cause within a top-level wrapper exception (for example, an IOException wrapped inside an IllegalStateException).
Alternatively, the annotation declaration may narrow the exception types to match:
@ExceptionHandler({FileSystemException.class, RemoteException.class})
Support for @ExceptionHandler methods in Spring MVC is built on the DispatcherServlet level, HandlerExceptionResolver mechanism.
@ExceptionHandler methods support similar return types and parameter types to the @RequestMapping methods

RestTemplate methods:
getForObject, getForEntity (returns a ResponseEntity instead of object representation), headForHeaders, postForLocation, postForObject, postForEntity, put, patchForObject, delete, optionsForAllow, exchange, execute

exchange - More generalized (and less opinionated) version of the preceding methods that provides extra flexibility when needed. It accepts a RequestEntity (including HTTP method, URL, headers, and body as input) and returns a ResponseEntity.

By default RestTemplate uses java.net.HttpUrlConnection. You can switch to a different HTTP library with an implementation of ClientHttpRequestFactory like Apache HttpComponents, Netty and OkHttp. The library can be switched by passing a reference to the RestTemplate constructor of the class implmenting ClientHttpRequestFactory.
the JDK HttpURLConnection does not support the PATCH, but Apache HttpComponents and others do

Note that the java.net implementation for HTTP requests can raise an exception when accessing the status of a response that represents an error (such as 401). If this is an issue, switch to another HTTP client library.

URI templates are automatically encoded, as the following example shows:
restTemplate.getForObject("https://example.com/hotel list", String.class);
// Results in request to "https://example.com/hotel%20list"

You can use the exchange() methods to specify request headers by using a RequestEntity to build up the request and add header fields.
You can obtain response headers through many RestTemplate method variants that return ResponseEntity.

Objects passed into and returned from RestTemplate methods are converted to and from raw content with the help of an HttpMessageConverter.
You need not explicitly set the Content-Type header of the request. the chosen message converter sets the content type accordingly for most RestTemplate methods.
If necessary the exchange() method can be used to explicitly set the request headers by passing a ResponseEntity

You can specify a Jackson JSON View to serialize only a subset of the object properties, as the following example shows:

MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
value.setSerializationView(User.WithoutPasswordView.class);

RequestEntity<MappingJacksonValue> requestEntity =
    RequestEntity.post(new URI("https://example.com/user")).body(value);

ResponseEntity<String> response = template.exchange(requestEntity, String.class);

To send multipart data, you need to provide a MultiValueMap<String, Object> whose values may be an Object for part content, a Resource for a file part, or an HttpEntity for part content with headers. 
The content type is determined automatically based on the HttpMessageConverter chosen to serialize it or, in the case of a Resource based on the file extension. If necessary, you can explicitly provide the MediaType with an HttpEntity wrapper. If the MultiValueMap contains at least one non-String value, the Content-Type is set to multipart/form-data by the FormHttpMessageConverter. If the MultiValueMap has String values the Content-Type is defaulted to application/x-www-form-urlencoded. If necessary the Content-Type may also be set explicitly.

We can enable Web MVC configuration in the following way:
@Configuration
@EnableWebMvc
public class WebConfig {}
The preceding example registers a number of Spring MVC infrastructure beans and adapts to dependencies available on the classpath (for example, payload converters for JSON, XML, and others).

WebMvcConfigurerAdapter - an interface that is deprecated in favor or WebMvcConfigurer. WebMvcConfigurer extends WebMvcConfigurerAdapter.

In Java based configuration this is achieved in a similar way. The difference is that we'll need to bootstrap the infrastructure beans by extending methods.
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    //register custom formatters and converters
    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }

    //customize global Validator instance
	//If you need to have a LocalValidatorFactoryBean injected somewhere, create a bean and mark it with @Primary in order to avoid conflict with the one declared in the MVC configuration.
	@Override
	public Validator getValidator() { ... }

	//register Validator implementations locally
	@InitBinder
	protected void initBinder(WebDataBinder binder) {
		binder.addValidators(new FooValidator());
	}

	// register custom interceptors	
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LocaleChangeInterceptor());
        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
    }

	@Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
		configurer.mediaType("json", MediaType.APPLICATION_JSON);
		configurer.mediaType("xml", MediaType.APPLICATION_XML);
	}

	//forward a request to / to a view called home
	//this is the equivalent of registering a ParameterizableViewController
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController("/").setViewName("home");
	}

	//configure message converters
	@Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
                .indentOutput(true)
                .dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
                .modulesToInstall(new ParameterNamesModule());
        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
    }

	//configure the registration of view resolvers
	//this example configures content negotiation view resolution by using JSP and Jackson as a default View for JSON rendering
	@Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.enableContentNegotiation(new MappingJackson2JsonView());
		registry.freeMarker.cache(false);
        registry.jsp();
    }

	// in Java-based configuration we can setup the according view template configurer as a bean
	@Bean
	public FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setTemplateLoaderPath("/freemarker");
		return configurer;
	}

	//configure path matching
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseSuffixPatternMatch(true)
            .setUseTrailingSlashMatch(false)
            .setUseRegisteredSuffixPatternMatch(true)
            .setPathMatcher(antPathMatcher())
            .setUrlPathHelper(urlPathHelper())
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }

    @Bean
    public UrlPathHelper urlPathHelper() {
        //...
    }

    @Bean
    public PathMatcher antPathMatcher() {
        //...
    }

	@Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
		//or pass a string to set the name of the default servlet name
		configurer.enable("myCustomDefaultServlet");
    }

	//static resources handling configuration
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
			.addResourceLocations("/public/")
			.resourceChain(true)
			.setCachePeriod(86400)
			.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
    }

}

org.springframework.format.support.FormattingConversionServiceFactoryBean - implements InitializingBean. Supports the following methods:
setConverters(Set<?> converters)
setEmbeddedValueResolver(StringValueResolver embeddedValueResolver)
setFormatterRegistrars(Set<FormatterRegistrar> formatterRegistrars)
setFormatters(Set<?> formatters)
setRegisterDefaultFormatters(boolean registerDefaultFormatters)

By default, if Bean Validation is present on the classpath (for example, Hibernate Validator), the LocalValidatorFactoryBean is registered as a global Validator for use with @Valid and Validated on controller method arguments.

ContentNegotiationManagerFactoryBean - registering this bean and setting the mediaTypes property is the same as overriding configureContentNegotiation method of WebMvcConfigurer

Spring MVC allows for mapping the DispatcherServlet to / (thus overriding the mapping of the container’s default Servlet), while still allowing static resource requests to be handled by the container’s default Servlet. It configures a DefaultServletHttpRequestHandler with a URL mapping of /** and the lowest priority relative to other URL mappings. This handler forwards all requests to the default Servlet. Therefore, it must remain last in the order of all other URL HandlerMappings. If you set up your own customized HandlerMapping instance, be sure to set its order property to a value lower than that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE. The caveat to overriding the / Servlet mapping is that the RequestDispatcher for the default Servlet must be retrieved by name rather than by path. The DefaultServletHttpRequestHandler tries to auto-detect the default Servlet for the container at startup time, using a list of known names for most of the major Servlet containers (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere). We can explicitly provide the default servlet name by overriding configureDefaultServletHandling() method in WebMvcConfigurer.

Spring 5 supports the Servlet 4 specification which on the other hand supports HTTP/2  In Spring 5 we can pass javax.servlet.http.PushBuilder objects as method arguments to @RequestMapping.

-- Spring Data, JDBC, JPA and Transactions

https://github.com/spring-projects/spring-data-examples
https://github.com/spring-projects/spring-data-book


The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation is to use the @Repository annotation. This annotation also lets the component scanning support find and configure your DAOs and repositories without having to provide XML configuration entries for them. Any DAO or repository implementation needs access to a persistence resource, depending on the persistence technology used. For example, a JDBC-based repository needs access to a JDBC DataSource, and a JPA-based repository needs access to an EntityManager. The easiest way to accomplish this is to have this resource dependency injected by using one of the @Autowired, @Inject, @Resource or @PersistenceContext(for JPA) annotations. Here's an example involving JPA:
@Repository
public class JpaMovieFinder implements MovieFinder {
	@PersistenceContext
	private EntityManager entityManager;
}
Here's an example involving JDBC:
@Repository
public class JdbcMovieFinder implements MovieFinder {
	private JdbcTemplate jdbcTemplate;
	@Autowired
	public void init(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}
}

Separate the DataSource and the business components that use it and control their startup order by putting them in separate ApplicationContext instances (for example, the parent context contains the DataSource, and the child context contains the business components). This structure is common in Spring web applications but can be more generally applied

Spring Data repositories are interfaces that you can define to access data. queries are created automatically from your method names. For more complex queries, you can annotate your method with Spring Data’s Query annotation.

---- transactions

javax.transaction.Transactional can be used as a drop-in replacement to org.springframework.transaction.annotation.Transactional
The default propagation of the @Transactional annotation is PROPAGATION_REQUIRED.

@Transactional can be annotated on the method level.
When using @Transactional on the class-level and not on any of the methods all of the methods will have the same level of propagation.

Dirty Reads: Transaction "A" writes a record. Meanwhile, Transaction "B" reads that same record before Transaction A commits. Later, Transaction A decides to rollback and now we have changes in Transaction B that are inconsistent. This is a dirty read. Transaction B was running in READ_UNCOMMITTED isolation level so it was able to read Transaction A changes before a commit occurred.
Non-Repeatable Reads: Transaction "A" reads some record. Then Transaction "B" writes that same record and commits. Later Transaction A reads that same record again and may get different values because Transaction B made changes to that record and committed. This is a non-repeatable read.
Phantom Reads: Transaction "A" reads a range of records. Meanwhile, Transaction "B" inserts a new record in the same range that Transaction A initially fetched and commits. Later Transaction A reads the same range again and will also get the record that Transaction B just inserted. This is a phantom read: a transaction fetched a range of records multiple times from the database and obtained different result sets (containing phantom records).

Range Lock - when a range of records is being locked

When it comes to transaction management, the JdbcTemplate class hooks in to the Spring transaction support and supports both JTA and JDBC transactions, through respective Spring transaction managers. For the supported ORM technologies, Spring offers Hibernate and JPA support through the Hibernate and JPA transaction managers as well as JTA support. 

The term unit of work usually represents a set of actions treated as one and undone also as one if needed.  The auto-commit mode of JDBC should be disabled so that sets of actions can be undone as one.  Select the one that applies best.

Optimistic Locking -  you read a record, take note of a version number (other methods to do this involve dates, timestamps or checksums/hashes) and check that the version hasn't changed before you write the record back. When you write the record back you filter the update on the version to make sure it's atomic. If the record is dirty (i.e. different version to yours) you abort the transaction and the user can re-start it.
Pessimistic Locking - when you lock the record for your exclusive use until you have finished with it. It has much better integrity than optimistic locking but requires you to be careful with your application design to avoid Deadlocks. To use pessimistic locking you need either a direct connection to the database (as would typically be the case in a two tier client server application) or an externally available transaction ID that can be used independently of the connection. In the latter case you open the transaction with the TxID and then reconnect using that ID. The DBMS maintains the locks and allows you to pick the session back up through the TxID. This is how distributed transactions using two-phase commit protocols (such as XA or COM+ Transactions) work.

Spring's declarative transaction uses the TransactionInterceptor class in its AOP proxies in applying transactional advice.
Spring framework's declarative transaction support is enabled via AOP proxies.
We can call setRollbackOnly() on the TransactionStatus object to roll back the current transaction.

Instances of the TransactionTemplate are threadsafe.
You can call the 'commit' method of PlatformTransactionManager to issue a commit.
The transaction name can be explicitly set only programatically.
You can call the 'rollback' method of PlatformTransactionManager to issue a rollback.

Here is a brief summary of the characteristics of the isolation levels.
     Read uncommitted
          dirty read can occur:  Yes
          non-repeatable read can occur:  Yes
          phantom read can occur:  Yes
     Read committed
          dirty read can occur:  No
          non-repeatable read can occur:  Yes
          phantom read can occur:  Yes
     Repeatable reads
          dirty read can occur:  No
          non-repeatable read can occur:  No
          phantom read can occur:  Yes
     Serializable
          dirty read can occur:  No
          non-repeatable read can occur:  No
          phantom read can occur:  No

Those are the default settings for the @Transactional annotation:
Propagation setting is PROPAGATION_REQUIRED.
Isolation level is ISOLATION_DEFAULT.
Transaction is read/write.
Transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported.
Any RuntimeException or java.lang.Error triggers rollback, and any checked Exception does not.

Those are the default <tx:advice/> settings:
The propagation setting is REQUIRED
The isolation level is DEFAULT
The transaction is read-write
Any RuntimeException or java.lang.Error triggers rollback, and any checked Exception does not.

Transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported.

Global vs Local Transactions:
https://docs.spring.io/spring/docs/5.1.10.BUILD-SNAPSHOT/spring-framework-reference/data-access.html#transaction-global

Typically, you need an application server’s JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. Many high-end applications use a single, highly scalable database (such as Oracle RAC) instead. Stand-alone transaction managers (such as Atomikos Transactions and JOTM) are other options. 
The Spring Framework gives you the choice of when to scale your application to a fully loaded application server. 

A transaction strategy is defined by the org.springframework.transaction.PlatformTransactionManager interface:
public interface PlatformTransactionManager {
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
PlatformTransactionManager is not tied to a lookup strategy such as JNDI. The getTransaction(..) method returns a TransactionStatus object, depending on a TransactionDefinition parameter. The returned TransactionStatus might represent a new transaction or can represent an existing transaction, if a matching transaction exists in the current call stack. A TransactionStatus object is associated with a thread of execution.
The TransactionDefiniton specifies:
- propagation - you can specify the behavior if a transactional method is executed when a transaction context already exists
- read-only status - You can use a read-only transaction when your code reads but does not modify data.
- isolation - The degree to which this transaction is isolated from the work of other transactions.
- timeout - How long this transaction runs before timing out and being automatically rolled back

defining the correct PlatformTransactionManager implementation is absolutely essential regardless of using declarative or programmatic transaction management.
If you use JTA in a Java EE container, then you use a container DataSource, obtained through JNDI, in conjunction with Spring’s JtaTransactionManager.
If you use Hibernate and Java EE container-managed JTA transactions, you should use the same JtaTransactionManager.

public interface TransactionStatus extends SavepointManager {
    boolean isNewTransaction();
    boolean hasSavepoint();
    void setRollbackOnly();
    boolean isRollbackOnly();
    void flush();
    boolean isCompleted();
}

PlatformTransactionManager interface, its implementations
JtaTransactionManager -----> JTA
DataSourceTransactionManager -----> JDBC
JpaTransactionManager ------> JPA - The recommended strategy for JPA is local transactions through JPA’s native transaction support.
HibernateTransactionManager ------> Hibernate

If you use global transactions JtaTransactionManager should be used.

When you want the application code to deal directly with the resource types of the native persistence APIs, you can use DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils (for Hibernate) to ensure that proper Spring Framework-managed instances are obtained, transactions are (optionally) synchronized, and exceptions that occur in the process are properly mapped to a consistent API.
Placing the @Transactional annotation on an interface (or an interface method), works only if you are using interface-based  (as opposed to class-based) proxies.  This is because Java annotations are not inherited from interfaces.
@EnableTransactionManagement and <tx:annotation-driven/> are responsible for registering the necessary Spring components that power annotation-driven transaction management, such as the TransactionInterceptor and the proxy- or AspectJ-based advice that weave the interceptor into the call stack when JdbcFooRepository's @Transactional methods are invoked.
A minor difference between the two examples lies in the naming of the PlatformTransactionManager bean: In the @Bean case, the name is "txManager" (per the name of the method); in the XML case, the name is "transactionManager". The <tx:annotation-driven/> is hard-wired to look for a bean named "transactionManager" by default, however @EnableTransactionManagement is more flexible; it will fall back to a by-type lookup for any PlatformTransactionManager bean in the container. Thus the name can be "txManager", "transactionManager", or "tm": it simply does not matter.

With the default configurations, unchecked exceptions cause a rollback within a transaction, as well as java.lang.Error. Checked exceptions don't cause this.

Normally, if a client code  (e.g. class MyClient) calls method1(), method1() will run under a new transaction  (because of the REQUIRES_NEW setting).  In the same way, normally, if a client code  (e.g. class MyClient) calls method2(), method2() will run under a new transaction  (because of the REQUIRES_NEW setting). 
However, if a client code  (e.g. class MyClient) calls method1(), and method1() calls method2(), method2() will run under the same transaction that method1() is running on.
Because Spring AOP is used to apply the transaction, if an AOP target method  (method1 in this example), calls another method in the same target object  (method2 in this example), method1 will be calling the method2 directly in the target object, and not through the AOP proxy  (thereby, the transaction settings of REQUIRES_NEW will not be applied by the proxy to the method2).
The Spring Reference says:
     "However, once the call has finally reached the target object, the SimplePojo reference in this case, any method calls that it may make on itself, such as this.bar() or this.foo(), are going to be invoked against the this reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to execute."
2.  @Transactional can be applied on methods and classes. A @Transactional annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present).
 Note that a class-level annotation does not apply to ancestor classes up the class hierarchy; in such a scenario, methods need to be locally redeclared in order to participate in a subclass-level annotation.

 If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider using AspectJ (described later).

In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional.

SingleConnectionDataSource - this wraps a signle connection that is not closed after each use. This is not multi threading capable.
@PersistenceUnit can be annotated on a property whose type is EntityManagerFactory. An implementation of EntityManagerFactory can create an EntityManager and use it to perform database operations.

The Spring Reference mentions that, the default @Transactional settings include below.
     Any RuntimeException triggers rollback, and any checked Exception does not. Also any java.lang.Error causes a rollback.
The Spring Reference describes  some of the possible ways of changing the default settings of the @Transactional annotation through these annotation attributes:
     rollbackFor
          Type:  Array of Class objects, which must be derived from Throwable.
          Description:  Optional array of exception classes that must cause rollback.
     rollbackForClassName
          Type:  Array of class names. Classes must be derived from Throwable.
          Description:  Optional array of names of exception classes that must cause rollback.
     noRollbackFor
          Type:  Array of Class objects, which must be derived from Throwable.
          Description:  Optional array of exception classes that must not cause rollback.
     noRollbackForClassName
          Type:  Array of String class names, which must be derived from Throwable.
          Description:  Optional array of names of exception classes that must not cause rollback.


------ jdbc

Data access approaches:
- JdbcTemplate simplifies JDBC data access code. Hibernate support comes in with another template called HibernateTemplate. From the JDBC data access classes JdbcTemplate is the classic and lowest level approach and all others use a JdbcTemplate under the covers. It handles the creation and release of resources, which helps you avoid common errors, such as forgetting to close the connection. The DataAccessExceptions that are thrown by JdbcTemplate are in the org.springframework.dao package. It performs iteration over ResultSet instances through callbacks
- NamedParameterJdbcTemplate wraps JdbcTemplate to provide named parameters instead of the traditional JDBC ? placeholders.
- SimpleJdbcInsert and SimpleJdbcCall - helper method to declare stored procedures in Spring Data JDBC. They utilize database metadata to limit the amount of necessary configuration.
- MappingSqlQuery, SqlUpdate and StoredProcedure - create reusable thread-safe objects during initialization of your data-access layer. You define your query string, declare parameters and compile the query

Package hierarchy:
- org.springframework.jdbc.core - contains the JdbcTemplate and the callbacks it uses. org.springframework.jdbc.core.simple contains the SimpleJdbcInsert and SimpleJdbcCall classes. org.springframework.jdbc.core.namedparam contains NamedParameterJdbcTemplate class and the related support classes.
- org.springframework.jdbc.datasource - contains a utility class for easier data source acess (DataSourceUtil) and various simplified DataSource implementations
- org.springframework.jdbc.object - contains classes that represent RDBMS queries, updates, and stored procedures as thread-safe, reusable objects.
- org.springframework.jdbc.support - provides SQLException transaction functionality and some utility classes. SQLExceptionTranslation class is used to translate the JDBC exceptions to DataAccessExceptions

JdbcTemplate callbacks:
- PreparedStatementCreator - creates a prepared statement
- CallableStatementCreator - creates callable statements
- RowCallbackHandler - extends values from each row of a ResultSet

You can use JdbcTemplate within a DAO implementation through direct instantiation with a DataSource reference, or you can configure it in a Spring IoC container and give it to DAOs as a bean reference. The DataSource should always be configured as a bean in the Spring IoC container. In the first case the bean is given to the service directly; in the second case it is given to the prepared template.

The difference between query and queryForObject methods in JdbcTemplate is that query returns a List of objects, while queryForObject returns a single object.
Here are example JdbcTemplate calls:
int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor where first_name = ?", Integer.class, "Joe"); //example with bind variable
String lastName = this.jdbcTemplate.queryForObject("select last_name from t_actor where id = ?", new Object[]{1212L}, String.class); //look for a string
A query to populate a single domain object:
Actor actor = this.jdbcTemplate.queryForObject("select first_name, last_name from t_actor where id = ?", new Object[]{1212L},
new RowMapper<Actor>() {
	public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
		Actor actor = new Actor();
		actor.setFirstName(rs.getString("first_name"));
		actor.setFirstName(rs.getString("last_name"));
		return actor;
	}
}});
this.jdbcTemplate.update("insert into t_actor (first_name, last_name) values (?, ?)", "Leonor", "Watling");
this.jdbcTemplate.update("update t_actor set last_name = ? where id = ?","Banjo", 5276L);
this.jdbcTemplate.update("delete from actor where id = ?", Long.valueOf(actorId));
this.jdbcTemplate.update("call SUPPORT.REFRESH_ACTORS_SUMMARY(?)", Long.valueOf(unionId));
this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
this.jdbcTemplate.queryForList("select * from mytable"); // returns a List<Map<String, Object>>.

An update convenience method supports the retrieval of primary keys generated by the database. It's part of the JDBC 3.0 standard
KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps = connection.prepareStatement("insert into my_test (name) values(?)", new String[] {"id"});
            ps.setString(1, "Rob");
            return ps;
        }
    },
    keyHolder);
// keyHolder.getKey() now contains the generated key

List<Actor> actors = //...;
this.jdbcTemplate.batchUpdate(
	"update t_actor set first_name = ?, last_name = ? where id = ?",
	new BatchPreparedStatementSetter() {
		public void setValues(PreparedStatement ps, int i) throws SQLException {
			ps.setString(1, actors.get(i).getFirstName());
			ps.setString(2, actors.get(i).getLastName());
			ps.setLong(3, actors.get(i).getId().longValue());
		}
		public int getBatchSize() {
			return actors.size();
		}
});
We can also use SqlParameterSourceUtils.createBatch for batch updates:
this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
The POJO properties' values with the same name as the placeholders will fill them.
We can also pass a List of object arrays to the batchUpdate method:
List<Object[]> batch = new ArrayList<Object[]>();
Object[] values = new Object[] {
		actor.getFirstName(), actor.getLastName(), actor.getId()};
batch.add(values);
this.jdbcTemplate.batchUpdate("update t_actor set first_name = ?, last_name = ? where id = ?", batch);
The batch update method returns an array of integers (int[] or int[][]) that contains the numbers of updated rows per statement. If the count is not available, the JDBC driver returns a value of -2.
SimpleJdbcInsert and SimpleJdbcCall examples:
1.Using a simple map that stores the column names and the new values
	this.jdbcTemplate = new JdbcTemplate(dataSource);
	this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
	Map<String, Object> parameters = new HashMap<String, Object>(3);
	parameters.put("id", actor.getId());
	parameters.put("first_name", actor.getFirstName());
	parameters.put("last_name", actor.getLastName());
	insertActor.execute(parameters); //returns an int with the number of updated rows
2. Use auto-generated keys:
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");

SqlParameter - this type can be used to define IN parameters for stored procedures for the SimpleJdbcCall::declareParameters method or for queries using SqlQuery
SqlOutParameter - this type can be used to define OUT parameters for stored procedures for the SimpleJdbcCall::declareParameters method or for queries using SqlQuery
SqlInOutParameter - this type describes an InOut parameter that can be used for both storing in and out values in a stored procedure

You can provide SQL type information in several ways:
- Many update and query methods of the JdbcTemplate take an additional parameter in the form of an int array. This array is used to indicate the SQL type of the corresponding parameter by using constant values from the java.sql.Types class. Provide one entry for each parameter.
- You can use the SqlParameterValue class to wrap the parameter value that needs this additional information. To do so, create a new instance for each value and pass in the SQL type and the parameter value in the constructor. You can also provide an optional scale parameter for numeric values.
- For methods that work with named parameters, you can use the SqlParameterSource classes, BeanPropertySqlParameterSource or MapSqlParameterSource. They both have methods for registering the SQL type for any of the named parameter values.

SqlQuery - reusable, thread-safe class that encapsulates an SQL query. Subclasses must implemnet the newRowMapper(..) method to provide a RowMapper instance that can create one objeect pr row obtained from iterating over the ResultSet that is created during the execution of the query. MappingSqlQuery subclass provides a much more convenient implementation for mapping rows to Java classes.

Controlling database connections
- DataSource - part of the JDBC specification and is a generalized connection factory. It lets a container or a framework hide connection pooling and transaction management issues from the application code
- org.apache.commons.dbcp.BasicDataSource and com.mchange.v2.c3p0.ComboPooledDataSource are DataSource implementations and have the same methods for setting up the datasource as DriverManagerDataSource.
- SmartDataSource - an interface extending DataSource. It can give information for classes that use it to close a connection or not. Useful for checking when to reuse a connection.
- AbstractDataSource - DataSource base class. It can be used to implement a custom DataSource implementation
- SingleConnectionDataSource - SmartDataSource implementation that wraps a single Connection that is not closed after each use. This is not multi-threading capable. In contrast to DriverManagerDataSource, it reuses the same connection all the time, avoiding excessive creation of physical connections. the suppressClose property should be set to true if any client code calls close on the assumption of a pooled connection. This is mainly a test class.
- DriverManagerDataSource - returns a new Connection each time. Useful for test and standalone environments outside of a Java EE container.
- DataSourceTransactionManager - PlatformTransactionManager implementation for single JDBC datasources. It builds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for one thread connection per data source

Most JDBC drivers provide improved performance if you batch multiple calls to the same prepared statement. By grouping updates into batches, you limit the number of round trips to the database.

The update method in JdbcTemplate can be used to execute insert and update statements and invoke stored procedures. The execute method can be used to execute any arbitrary SQL. The main difference between execute and update is that execute returns void and update returns the number of rows the query updated successfully / number of affected rows.
queryForObject throws an IncorrectResultSizeDataAccessException exception when more than one row is retrieved or no result is retrieved.

When you use the JdbcTemplate for your code, you only need to implement callback interfaces, giving them a clearly defined contract. The PreparedStatementCreator callback interface creates a prepared statement given a Connection provided by this class, providing SQL and any necessary parameters. The same is true for the CallableStatementCreator interface, which creates callable statements. The RowCallbackHandler interface extracts values from each row of a ResultSet.

JdbcTemplate catches JDBC exceptions and rethrows them in the Spring exception hierarchy.
JdbcTemplate handles the creation and the release of resources.

After getting configured, instances of the JdbcTemplate are threadsafe. This is important because it means that you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs (or repositories). If your application accesses multiple databases, you may want multiple JdbcTemplate instances, which require multiple DataSource beans and subsequently, multiple differently configured JdbcTemplate instances.

JdbcTemplate has a property whose type is DataSource.
it is threadsafe to inject a single configured instance of a JdbcTemplate reference into multiple DAOs.

NamedParameterJdbcTemplate - this JdbcTemplate wrapper allows us to use named placeholders in SQL queries instead of question marks as in the JdbcTemplate syntax 
namedParameters = new MapSqlParameterSource("first_name", firstName);
// or Map<String, String> namedParameters = Collections.singletonMap("first_name", firstName);
this.namedParameterJdbcTemplate.queryForObject("select count(*) from T_ACTOR where first_name = :first_name", namedParameters, Integer.class);
We can also use BeanPropertySqlParameterSource -it wraps a JavaBean POJO and uses it's property values to fill the placeholders.

Spring's DriverManagerDataSource does not provide pooling. This class is not an actual connection pool; it does not actually pool Connections. It just serves as simple replacement for a full-blown connection pool, implementing the same standard interface, but creating new Connections on every call.
It is an implementation of the standard javax.persistence.DataSource that configures a plain JDBC driver through bean properties and returns a new connection every time. This configuration is useful for test and standalone environments outside of a Java EE container.
DriverManagerDataSource myDataSource = new DriverManagerDataSource();
myDataSource.setDriverClassName(.....);
myDataSource.setUrl(.....);
myDataSource.setUsername(.....);
myDataSource.setPassword(.....);

The following are true about JdbcTemplate:
- JdbcTemplate has a property whose type is DataSource
- After getting configured, instances of the JdbcTemplate class are threadsafe
- it is thread-safe to inject a single configured instance of a JdbcTemplate reference into multiple DAOs
- JdbcTemplate's 'update' method can execute stored procedures
- It catches JDBC exteptions and translates them to the generic, more informative, DataAccessException exception hierarchy
- it performs iteration over ResultSets and extraction of returned parameter values
- it can use the RowCallbackHandler interface which extracts values from each row of a ResultSet

Here's a JDBC-based example:
Connection conn = DataSourceUtils.getConnection(dataSource);
If an existing transaction already has a connection synchronized (linked) to it, that instance is returned. Otherwise, the method call triggers the creation of a new connection, which is (optionally) synchronized to any existing transaction and made available for subsequent reuse in that same transaction.

At the very lowest level exists the TransactionAwareDataSourceProxy class. This is a proxy for a target DataSource, which wraps the target DataSource to add awareness of Spring-managed transactions.
If an existing transaction already has a connection synchronized (linked) to it, that instance is returned. Otherwise, the method call triggers the creation of a new connection, which is (optionally) synchronized to any existing transaction and made available for subsequent reuse in that same transaction.

Spring Framework's declarative transaction management is implemented via Spring AOP. It is not tied to JTA as opposed to EJB CMT. It can work with JTA transactions or local transactions by using JDBC, JPA or Hibernate by adjusting the configuration files. Custom behavior in case of rollback can be inserted using AOP.
The combination of AOP with transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with an appropriate PlatformTransactionManager implementation to drive transactions around method invocations.

The Spring framework provides two means of programmatic transaction management by using:
- The TransactionTemplate
- A PlatformTransactionManager implementation directly - similar to using JTA's UserTransaction API although exception handling is less cumbersome

@Transactional options:
- transactionManager - the name of the transaction manager bean (transactionManager is the default, needs to be specified if otherwise). This is the implicit value annotation.
- mode - default is proxy. Another option is aspectj. The proxy option sets Spring AOP  The aspectj option sets AspectJ transaction aspect to proxy the object. AspectJ weaving requires spring-aspects.jar in the classpath as well as having load-time weaving (or compile-time weaving) enabled.
- proxyTargetClass - default value is false. Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If the proxy-target-class attribute is set to true, class-based proxies are created. If proxy-target-class is false, then standard JDK interface-based proxies are created.
- order - defines the order of the transaction advice that is applied to beans annotated with @Transactional. if not specified the AOP system determines this.
- propagation - enum:Propagation
- isolation - enum:Isolation
- timeout - int (in seconds of granularity)
- readOnly (boolean)
- rollbackFor - array of Class objects, which must be derived from Throwable (optional)
- rollbackForClassName - array of class names, derived from throwable which cause a rollback (strings, not class names)
- noRollbackFor - array of class objects which are Throwable subtypes (optional)
- noRollbackForClassName - Array of String class names, which must be derived from Throwable.

Transaction propagation types:
- PROPAGATION_REQUIRED - logical transaction scope is created for each method upon which the setting is applied. All these logical transactions are mapped to a physical transaction. The logical transactions settings are independent of the settings of the physical transaction. The don't get overriden by them. The outer caller needs to receive an UnexpectedRollbackException to indicate clearly that a rollback was performed instead.
- PROPAGATION_REQUIRES_NEW - always uses an independent physical transaction for each affected transaction scope, never participating in an existing transaction for an outer scope.  In such an arrangement, the underlying resource transactions are different and, hence, can commit or roll back independently, with an outer transaction not affected by an inner transaction’s rollback status and with an inner transaction’s locks released immediately after its completion.
- PROPAGATION_NESTED - uses a single physical transaction with multiple savepoints that it can roll back to. This setting is typically mapped onto JDBC savepoints, so it works only with JDBC resource transactions.

Example code using TransactionTemplate - an anonymous class implementation is created here with TransactionCallback
public class SimpleService implements Service {
    // single TransactionTemplate shared amongst all methods in this instance
    private final TransactionTemplate transactionTemplate;
    // use constructor-injection to supply the PlatformTransactionManager
    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }
    public Object someServiceMethod() {
        return transactionTemplate.execute(new TransactionCallback() {
            // the code in this method executes in a transactional context
            public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
            }
        });
    }
}
If there is no return value, you can use the convenient TransactionCallbackWithoutResult class with an anonymous class. The TransactionCallbackWithoutResult anonymous implementation needs to implement the doInTransactionWithoutResult method.
The TransactionCallback implemnetations represent what happens within our transactions.
When implementing the doInTransaction... methods we can pass a TransactionStatus object as parameter and call the setRollbackOnly() method in the catch block to handle exceptions.

This is how we can specify options of the Transaction template. By default, TransactionTemplate instances have the default transaction settings.
public SimpleService(PlatformTransactionManager transactionManager) {
	this.transactionTemplate = new TransactionTemplate(transactionManager);

	// the transaction settings can be set here explicitly if so desired
	this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
	this.transactionTemplate.setTimeout(30); // 30 seconds
	// and so forth...
}
instances of the TransactionTemplate class are thread-safe, in that instances do not maintain any conversational state. TransactionTemplate instances do, however, maintain configuration state. So, while a number of classes may share a single instance of a TransactionTemplate, if a class needs to use a TransactionTemplate with different settings (for example, a different isolation level), you need to create two distinct TransactionTemplate instances.

explicitly setting the transaction name is something that can be done only programmatically

We can also use PlatformTransactionManager to handle transactions directly. We need to register a PlatformTransactionManager bean to use TransactionDefinition and TransactionStatus object to initiate transactions, roll back and commit.

DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);

We can annotate a method with @TransactionalEventListener on a method 

The @TransactionalEventListener is an event listener that is invoked according to a TransactionPhase. The valid phases are BEFORE_COMMIT, AFTER_COMMIT (default), AFTER_ROLLBACK, and AFTER_COMPLETION that aggregates the transaction completion (be it a commit or a rollback).

Consider switching the validateExistingTransactions flag to true on your transaction manager if you want isolation level declarations to be rejected when a new transaction is participating in an existing transaction with a different isolation level.

Currently, you cannot have explicit control over the name of a transaction, where 'name' means the transaction name that appears in a transaction monitor, if applicable (for example, WebLogic’s transaction monitor), and in logging output. For declarative transactions, the transaction name is always the fully-qualified class name + . + the method name of the transactionally advised class

@Transactional can be used as a meta-annotaiton also. If we repeatedly use @Transactional with the same settings we can create our own annotaiton and annotate it with @Transactional set with those options and use the new annotation instead from now on.

The following code shows how to programmatically indicate a required rollback:
public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}

Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration. Runtime exceptions and java.lang.Error do
LocalSessionFactoryBean - FactoryBean that creates a Hibernate SessionFactory. Part of the integration between Hibernate 5 and Spring. your application code can use that bean to obtain Hibernate Session instances.

as the DataSourceTransactionManager needs a reference to the DataSource, the HibernateTransactionManager needs a reference to the SessionFactory.

If the DataSource (used by any non-JTA transaction manager) is looked up through JNDI and managed by a Java EE container, it should be non-transactional, because the Spring Framework (rather than the Java EE container) manages the transactions.

@Entity is part of JPA. @Entity can be annotated on classes only.

Explanation:
The Spring Reference says:
     "The DataSourceTransactionManager class is a PlatformTransactionManager implementation for single JDBC datasources. It binds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for one thread connection per data source."
There is no JDBCTransactionManager, JDBCDataSourceTransactionManager, or JDBCPlatformTransactionManager for this purpose.
Reference
13.3.8. DataSourceTransactionManager
  *  http://docs.spring.io/spring-framework/docs/4.0.9.RELEASE/spring-framework-reference/html/jdbc.html#jdbc-DataSourceTransactionManager
  *  Spring Framework Reference Documentation 4.0.9.RELEASE

Explanation:
The Spring Reference says:
     "Application code that must execute in a transactional context, and that will use the TransactionTemplate explicitly, looks like the following. You, as an application developer, write a TransactionCallback implementation (typically expressed as an anonymous inner class) that contains the code that you need to execute in the context of a transaction. You then pass an instance of your custom TransactionCallback to the execute(..) method exposed on the TransactionTemplate."
The Spring API document describes the TransactionInterceptor, as:
     "AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager)."
The Spring Reference says:
     "The TransactionStatus interface provides a simple way for transactional code to control transaction execution and query transaction status."
The Spring Reference says:
     "The key to the Spring transaction abstraction is the notion of a transaction strategy. A transaction strategy is defined by the org.springframework.transaction.PlatformTransactionManager interface"
Below is an example.
     <bean id="transactionInterceptor"
          class="org.springframework.transaction.interceptor.TransactionInterceptor">
          <property name="transactionManager" ref="transactionManager"></property>
          .....
     </bean>
Below is an example.
     public Object someServiceMethod() {
          return transactionTemplate.execute(new TransactionCallback() {
               public Object doInTransaction(TransactionStatus status) {
                    doADatabaseUpdateHere();
                    .....
               }
          });
     }
Reference
11.6.1. Using the TransactionTemplate
  *  http://docs.spring.io/spring-framework/docs/4.0.9.RELEASE/spring-framework-reference/html/transaction.html#tx-prog-template
  *  Spring Framework Reference Documentation 4.0.9.RELEASE


------ jpa

public interface CrudRepository<T, ID> extends Repository<T, ID> {
	<S extends T> S save(S entity); // saves the given entity
	Optional<T> findById(ID primaryKey); //returns the entity identified by the given ID
	Iterable<T> findAll(); //returns all entities
	long count(); // returns the number of entities
	void delete(T entity); // deletes the given entity
	boolean existsById(ID primaryKey); //indicates whether an entity with the given ID exists
}
We also provide persistence technology-specific abstractions, such as JpaRepository or MongoRepository. Those interfaces extend CrudRepository
On top of the CrudRepository, there is a PagingAndSortingRepository abstraction that adds additional methods to ease paginated access to entities:
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
	Iterable<T> findAll(Sort sort);
	Page<T> findAll(Pageable pageable);
}

To access the second page of User by a page size of 20, you could do something like the following:
PagingAndSortingRepository<User, Long> repository = // ...get access to a bean
Page<User> users = repository.findAll(PageRequest.of(1, 20));
Alternatively, if you do not want to extend Spring Data interfaces (Repository, CrudRepository and PagingAndSortingRepository) you can also annotate your repository interface with @RepositoryDefinition.
@NoRepositoryBean - we can annotate interfaces extending *Repository interfaces so that Spring Data will not create instances from them at runtime.
We can also extend the Spring Data repository interfaces to provide our own custom implementations of repositories instead of Spring Data generating the implementations at runtime. Those custom implementations could be regular Spring beans and dependencies to them could be autowired. The most important part of custom implementations is the "Impl" part that should be added after the base interface name (e.g. CustomizedUserRepositoryImpl implements CustomizedUserRepository)

@RepositoryDefinition(domainClass=MyCompany.class, idClass=String.class)

The repository proxy has two ways to derive a store-specific query from the method name:
- by deriving the query from the method name directly
- by using a manually defined query

The queryLookupStrategy opiton in @Enable{store}Repository annotations can be used to select from some of the available lookup strategies for the repository infrastructure to resolve queries:
- CREATE - attempts to construct a store-specific query from the method name
- USE_DECLARED_QUERY - tries to use an already declared query. If the query cannot be found an exception is thrown
- CREATE_IF_NOT_FOUND (default) - it looks up a declared query first, and, if no declared query is found, it creates a custom method name-based query

Queries can be generated from methods containing the followin: find...By, read...By, query...By, count...By and get...By
"Or" and "And" could be used similarly as OR and AND in SQL. Some example query methods:
  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);
  List<Person> findByLastnameIgnoreCase(String lastname);
  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);
  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
 You also get support for operators such as Between, LessThan, GreaterThan, and Like for the property expressions.
Pageable, Slice and Sort can be passed as argument to those query methods so that the repository infrastructure will apply paging and sorting to your queries dynamically.
A Page knows about the total number of elements and pages available.
A Slice only knows about whether a next Slice is available, which might be sufficient when walking through a larger result set.
Sorting options are handled through the pageable instance also 
If you only needs sorting you can add a org.springframework.data.domain.Sort parameter to your method.
//we can use the Sort.Direction enum values (ASC and DESC) to specify the direction of the sort
userRepository.findAll(new Sort(Sort.Direction.ASC, "name"));
//we can sort by the output of an aggregate function
userRepository.findAll(new Sort("LENGTH(name)"));

Here's an example:
Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());
Type-safe sort:
TypedSort<Person> person = Sort.sort(Person.class);
TypedSort<Person> sort = person.by(Person::getFirstname).ascending()
  .and(person.by(Person::getLastname).descending());

The results of query methods can be limited by using the first or top keywords. An optional numeric value can be added to specify the maximum result size.
Page<User> queryFirst10ByLastname(String lastname, Pageable pageable);
Slice<User> findTop3ByLastname(String lastname, Pageable pageable);
List<User> findFirst10ByLastname(String lastname, Sort sort);
The limiting expressions also support the Distinct keyword. Also, for the queries limiting the result set to one instance, wrapping the result into with the Optional keyword is supported.
Query methods that return multiple results can use standard Java Iterable, List and Set, as well as Spring Data's Streamable (a custom extension of Iterable), as well as collection types provided by Vavr. As of Spring Data 2.0, repository CRUD methods that return an individual aggregate instance use Java 8's Optional to indicate the potential absence of a value.

We can use nullability annotations in Spring-based repositories:
@NonNullApi - this is a package-level annotation (needs to be placed in package-info.java) to indicate that the default behavior for parameters and return values of methods in this package is to not accept or produce null values
@NonNull - used on a parameter or return value that must not be null
@Nullable - used on a parameter or return value that can be null

Example:
  @Nullable 
  User findByEmailAddress(@Nullable EmailAddress emailAdress);

@Entity indicates that a class is a JPA entity. JPA requires have a default, no argument constructor. This constructor can be public or protected. The entity class must be a top-level class. An enum or interface must not be designated as an entity. The Entity class must not be final. No method may be final within an @Entity class. Both abstract and concrete classes can be entities.
@EnableJpaRepositores enables interface-based repositories for JPA.
@EnableJdbcRepositores enables interface-based repositories for JDBC.
The Spring Data reference documentation mentions below as an example.
     public interface PersonRepository extends Repository<User, Long> {
       List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
       // Enables the distinct flag for the query
       List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
       List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);
       // Enabling ignoring case for an individual property
       List<Person> findByLastnameIgnoreCase(String lastname);
       // Enabling ignoring case for all suitable properties
       List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);
       // Enabling static ORDER BY for a query
       List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
       List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
     }
'list' is not a valid finder method name prefix in Spring Data.
Reference
1.3.2 Defining query methods
  *  https://docs.spring.io/spring-data/jpa/docs/1.3.0.RELEASE/reference/html/repositories.html#repositories.query-methods.details

Spring makes it easy to create and bind a Session to the current thread transparently, by exposing a current Session through the Hibernate SessionFactory. Additionally, JDBC-related code can fully integrate transactionally with the code you use to do ORM. This is useful for data access that is not suitable for ORM (such as batch processing and BLOB streaming) but that still needs to share common transactions with ORM operations.

The Spring JPA, available under the org.springframework.orm.jpa package, offers comprehensive support for the Java persisstence API in a manner similar to the integration with Hibernate while being aware of the underlying implementation in order to provide additional features.

There are three options for obtaining the EntityManagerFactory JPA object that is used by the application to obtain an entity manager:
- Using LocalEntiyManagerFactoryBeean - this option is suitable only for development environments and integration tests where only JPA is used for data access. The factory bean uses the JPA PersistenceProvider auto-detection mechanism (according to JPA’s Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name. You cannot refer to an existing JDBC DataSource bean definition, and no support for global transactions exists. Runtime weaving is provider-specific
- Obtaining an EntityManagerFactory from JNDI - you can use this option when deploying to a Java EE server. The Java EE server scans the META-INF/persistence.xml files in application jars. In such a scenario, the entire persistence unit deployment, including the weaving (byte-code transformation) of persistent classes, is up to the Java EE server. 
- Using LocalContainerEntityManagerFactoryBean - You can use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat, stand-alone applications, and integration tests with sophisticated persistence requirements. The LocalContainerEntityManagerFactoryBean creates a PersistenceUnitInfo instance based on the persistence.xml file, the supplied dataSourceLookup strategy, and the specified loadTimeWeaver. Using the LocalContainerEntityManagerFactoryBean is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC DataSource, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation.

A PersistenceUnitManager bean could be setup for managing multiple persistence units. The persistenceXmlLocations, datatSources and defaultDataSource properties of this bean (bean dependencies could be specified to specify multiple data sources and multiple persistence*.xml files).

EntityManagerFactory instances are thread safe, EntityManager instances are not.

Spring can understand the @PersistenceUnit and @PersistenceContext annotations both at the field and the method level if a PersistenceAnnotationBeanPostProcessor is enabled. As an alternative to explicitly defining a PersistenceAnnotationBeanPostProcessor, consider using the Spring context:annotation-config XML element in your application context configuration. Doing so automatically registers all Spring standard post-processors for annotation-based configuration, including CommonAnnotationBeanPostProcessor and so on.

transactional / shared EntityManager because it is a shared, thread-safe proxy for the actual transactional EntityManager. We can enable one by annotating a property of type EntityManager with @PersistenceContext.

As an alternative to JpaTransactionManager, Spring also allows for multi-resource transaction coordination through JTA, either in a Java EE environment or with a stand-alone transaction coordinator, such as Atomikos and Bitronix. To use Spring's JtaTransaction manager there are a few requirements:
- The underlying JDBC connection pools need to be XA-capable
- consider obtaining the EntityManagerFactory from your application server itself (that is, through a JNDI lookup instead of a locally declared LocalContainerEntityManagerFactoryBean).
The JPA EntityManagerFactory setup needs to be configured for JTA. This is provider-specific, typically through special properties to be specified as jpaProperties on LocalContainerEntityManagerFactoryBean.

JPQL - java persistence query language

@Query - we can use this JPA annotation on repository methods to define what SQL a Spring Data repository method will use. It's value attribute contains the JPQL or SQL to execute. By default the query definition uses JPQL.

Here's a simple query method that returns active User entities from the database:
@Query("SELECT u FROM User u WHERE u.status = 1")
Collection<User> findAllActiveUsers();

To use a native SQL query we need to set the nativeQuery attribut to true:
@Query(
	value = "SELECT * FROM USERS u WHERE u.status = 1",
	nativeQuery = true)
Collection<User> findAllActiveUsersNative();

When we use JPQL to sort the returned entities all we have to do is pass a Sort parameter to the method:
@Query(value = "SELECT u FROM User u")
List<User> findAllUsers(Sort sort); //it sorts by the entity @Id by default
userRepository.findAllUsers(new Sort("name")); //we can pass a fieldname as constructor
When we use a native SQL query it is not possible to define a Sort.

Using pagination with the @Query annotation is straightforward in JPQL:
@Query(value = "SELECT u FROM  User u ORDERB BY id")
Page<User> findAllUsersWithPagination(Pageable pageable);

With a native query we need to pass a query string to the countQuery attribute:
@Query(
	value = "SELECT * FROM Users ORDER BY id",
	countQuery = "SELECT count(*) FROM Users",
	nativeQuery = true)
Page<User> findAllUsersWithPagination(Pageable pageable);

With @Query we can also pass parameters to the query. This is how this is achieved in JPQL. Spring Data will pass method parameters to the query in the same order they appear in the method declaration:@Query("SELECT u FROM User u WHERE u.status = ?1")
User findUserByStatus(Integer status);
@Query("SELECT u FROM User u WHERE u.status = ?1 and u.name = ?2")
User findUserByStatusAndName(Integer status, String name);

With native queries, they work in the same way:
@Query(
  value = "SELECT * FROM Users u WHERE u.status = ?1", 
  nativeQuery = true)
User findUserByStatusNative(Integer status);

We can use the @Param annotation on method parameters to use named placeholders. The syntax is the same for native queries and JPQL:
@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name")
User findUserByStatusAndNameNamedParams(
  @Param("status") Integer stats, // the method parameter name doesn't need to have the same name as the place holder
  @Param("name") String name);

We can define @Query annotated methods that return a colllection (List, Set, HashSet etc.) and have a collection as a parameter
@Query(value = "SELECT u FROM User u WHERE u.name IN :names")
List<User> findUserByNameList(@Param("names") Collection<String> names);

@Modifying - we can annotate this method on @Query - annotated methods that modify the database:
@Modifying
@Query("update User u set u.status = :status where u.name = :name")
int updateUserSetStatusForName(@Param("status") Integer status, 
  @Param("name") String name); // the method here returns the number of affected rows
To perform an INSERT query we need to both use @Modifying and a native query because the INSERT query is not a part of the JPA interface

When using the @Query annotation:
- JPQL can be used with it
- Native SQL can be used with it by setting the nativeQuery flag to true
- It can be used in Spring Data Jpa
- it allows manual definition of the query to be executed by a repository method.
- the @Query annotation allows to execute native queries by setting the 'native' flag to true
- it does not support the pagination or dynamic sorting of native queries
- Queries defined using @Query will take precedence over queries annotated to the query method using @NamedQuery or declared in orm.xml

The Spring Data reference says:
     "Queries annotated to the query method will take precedence over queries defined using @NamedQuery or named queries declared in orm.xml.
The @Query annotation allows to execute native queries by setting the 'nativeQuery' flag to true. Note, that we currently don't support execution of pagination or dynamic sorting for native queries as we'd have to manipulate the actual query declared and we cannot do this reliably for native SQL."

The execution of pagionaton or dynamic sorting for native queries is not supported.

@Column - this is an annotation from the JDBC specification. When the NamingStrategy does not matching on your database column names, you can customize the names with the @Column annotation.
@Column(name="description", nullable=false, length=512, columnDefinition="CLOB NOT NULL", table="DETAILS", updatable=false)
public String getDesc() { return description; }

@Column(name="value", precision=12, scale=2)
public BigDecimal getCost() { return cost; }

-- Testing

org.springframework:spring-test - Spring test framework package

Spring’s test framework caches application contexts between tests. Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once.

These are the options provided by spring-test to test separate parts of a spring web application:
- Servlet API Mocks - Mock implementations of Servlet API contracts for unit testing controllers, filters, and other web components. It does not use a running Servlet container. It's based on mock objects from spring-test. It uses DispatcherServlet to provide full Spring MVC runtime behavior and provides support for loading actual Spring configuration with the TextContext framework in addition to a standalone mode where controllers can be instantiated manually and tested one at a time. Provides also client side support for testing code using RestTemplate. Client-side tests mock the server responses and also do not use a running server.
- TestContext Framework - Support for loading Spring configuration in JUnit and TestNG tests including efficient caching of the loaded configuration across test methods and support for loading a WebApplicationContext with a MockServletContext. Located in the org.springframework.test.context package. 
- Spring MVC Test - a framework also known as MockMvc, for testing annotated controllers through the DispatcherServlet - supporting annotations and complete with Spring MVC infrasructure, but
without an HTTP server. It also has two setup modes, similaraly to Servlet API Mocks - standalone setup and loading a full WebApplicationContext through TestContext framework.
- Client-side REST - spring-test provides a MockRestServiceServer that can be used as a mock server for testing client-side code that internally uses the RestTemplate.
- WebTestClient - can be used for testing WebFlux applications. it has integrations with HtmlUnit and Selenium

Spring's integration testing support has the following primary goals:
- to manage Spring IoC container caching between test execution
- to provide dependency injection of test fixture instances
- to provide transaction management appropriate to integration testing
- to supply Spring-specific base classes that assist developers in writing integration tests

List of objects in org.springframework.mock.web:
DelegatingServletInputStream - Delegating implementation of ServletInputStream.
DelegatingServletOutputStream - Delegating implementation of ServletOutputStream.
MockAsyncContext - Mock implementation of the AsyncContext interface.
MockBodyContent	- Mock implementation of the BodyContent class.
MockExpressionEvaluator	- Mock implementation of the JSP 2.0 ExpressionEvaluator interface, delegating to the Apache JSTL ExpressionEvaluatorManager.
MockFilterChain	- Mock implementation of the FilterChain interface.
MockFilterConfig - Mock implementation of the FilterConfig interface.
MockHttpServletRequest - Mock implementation of the HttpServletRequest interface.
MockHttpServletResponse	- Mock implementation of the HttpServletResponse interface.
MockHttpSession	- Mock implementation of the HttpSession interface.
MockJspWriter - Mock implementation of the JspWriter class.
MockMultipartFile - Mock implementation of the MultipartFile interface.
MockMultipartHttpServletRequest	- Mock implementation of the MultipartHttpServletRequest interface.
MockPageContext	- Mock implementation of the PageContext interface.
MockPart - Mock implementation of javax.servlet.http.Part.
MockRequestDispatcher - Mock implementation of the RequestDispatcher interface.
MockServletConfig - Mock implementation of the ServletConfig interface.
MockServletContext - Mock implementation of the ServletContext interface.
MockSessionCookieConfig	- Mock implementation of the SessionCookieConfig interface.
PassThroughFilterChain - Implementation of the FilterConfig interface which simply passes the call through to a given Filter/FilterChain combination (indicating the next Filter in the chain along with the FilterChain that it is supposed to work on) or to a given Servlet (indicating the end of the chain).

It is recommended to use a test runner's test lifecycle callback annotations instead of @PreDestroy and @PostConstruct within a unit test.

There are two ways of creating a MockMvc instance:
- The first is to load Spring MVC configuration through the TestContext framework, which loads the Spring configuration and injects a WebApplicationContext into the test to use to build a MockMvc instance
- The second is to simply create a controller instance manually without loading Spring configuration.

This is a sample way to create a standalone test:
MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

Here are some MockMvc examples.
It’s easy to perform requests using any HTTP method:
mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));
You can also perform file upload requests that internally use MockMultipartHttpServletRequest so that there is no actual parsing of a multipart request but rather you have to set it up:
mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));
You can specify query parameters in URI template style:
mockMvc.perform(get("/hotels?foo={foo}", "bar"));
Or you can add Servlet request parameters representing either query or form parameters:
mockMvc.perform(get("/hotels").param("foo", "bar"));
If you must test with the full request URI, be sure to set the contextPath and servletPath accordingly so that request mappings will work:
mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))
Add a servlet filter to a standalone setup:
mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();

//the following test asserst that binding or validation failed:
mockMvc.perform(post("/persons"))
    .andDo(print()) //useful for dumping the response results
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"))
	.andReturn(); //get direct access to the result

If all the tests have the same expectations you can set up common expectations once when building the MockMvc instance:
standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();

When setting up a MockMvc instance, you can register one or more Servlet Filter instances:
mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();

MockMvc expectations fall in two general categories. The first category of assertions verifies properties of the response: for example, the response status, headers, and content. These are the most important results to assert.
The second category of assertions goes beyond the response. These assertions allow one to inspect Spring MVC specific aspects such as which controller method processed the request, whether an exception was raised and handled, what the content of the model is, what view was selected, what flash attributes were added, and so on. They also allow one to inspect Servlet specific aspects such as request and session attributes.

When querying database to confirm state during testing, there is a need to flush the database yourself to avoid false positives.
@RunWith is a JUnit annotation.
Reference
Standard Annotation Support
  *  http://docs.spring.io/spring-framework/docs/4.0.9.RELEASE/spring-framework-reference/html/testing.html#integration-testing-annotations-standard
  *  Spring Framework Reference Documentation 4.0.9.RELEASE
Meta-Annotation Support for Testing

When using MockHttpServletRequest for unit tests whatever you add to it is what the request will be. Things that may catch you by surprise are that there is no context path by default, no jsessionid cookie, no forwarding, error, or async dispatches, and therefore no actual JSP rendering. Instead, "forwarded" and "redirected" URLs are saved in the MockHttpServletResponse and can be asserted with expectations.
This means if you are using JSPs you can verify the JSP page to which the request was forwarded, but there won’t be any HTML rendered. In other words, the JSP will not be invoked. Note however that all other rendering technologies which don’t rely on forwarding such as Thymeleaf and Freemarker will render HTML to the response body as expected. The same is true for rendering JSON, XML, and other formats via @ResponseBody methods.

@BootstrapWith is a class-level annotation that is used to configure how the Spring TestContext Framework is bootstrapped. It is used to specify a custom TestContextBootstrapper.

When you use the DependencyInjectionTestExecutionListener — which is configured by default — the dependencies of your test instances are injected from beans in the application context that you configured with @ContextConfiguration.

Those are valid options for the @ContextConfiguration annotation:
@ContextConfiguration("/test-config.xml") // implicit value annotation field
@ContextConfiguration({"/test-config.xml", "/app-config.xml"}) //implicit value annotation field
// pass a Java-based config
@ContextConfiguration(classes = TestConfig.class)
@ContextConfiguration(classes = {TestConfigOne.class, TestConfigTwo.class})
// register a custom context initializer class
@ContextConfiguration(initializers = CustomContextIntializer.class)
// can be used to setup a custom context initializer
@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class)
// we can use custom ApplicationContext initializers (classes that implement ApplicationContextInitializer.
// the order in which they are invoked depends on if they implemented Spring's Ordered interface, or annotated with the @Order annotation or
// the standard @Priority annotation
@ContextConfiguration(
	classes = TestConfig.class,
	initializers = TestAppCtxInitializer.class)
public class MyTest { ... }
inheritLocations and inheritInitializers - fields in the annotation which denote wether context definition locations and initializers should be inherited from parent classes. The default value is set to true for both.

The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a static variable. 
spring.test.context.cache.maxSize - spring property that sets the Spring context cache size. The default maximum size is 32. Whenever the maximum size is reached, a least recently used (LRU) eviction policy is used to evict and close stale contexts. To view the statistics for the underlying context cache, simply set the log level for the org.springframework.test.context.cache logging category to DEBUG.

An ApplicationContext can be uniquely identified by the combination of configuration parameters that is used to load it. Consequently, the unique combination of configuration parameters is used to generate a key under which the context is cached. The TestContext framework uses the following configuration parameters to build the context cache key:
locations (from @ContextConfiguration)
classes (from @ContextConfiguration)
contextInitializerClasses (from @ContextConfiguration)
contextCustomizers (from ContextCustomizerFactory)
contextLoader (from @ContextConfiguration)
parent (from @ContextHierarchy)
activeProfiles (from @ActiveProfiles)
propertySourceLocations (from @TestPropertySource)
propertySourceProperties (from @TestPropertySource)
resourceBasePath (from @WebAppConfiguration)

If you ommit both the locations and value fields, GenericXmlContextLoader and GenericXmlWebContextLoader will detect a default location based on the name of the test class. If your class is named com.example.MyTest, GenericXmlContextLoader loads your application context from "classpath:com/example/MyTest-context.xml". Same applies for ommiting groovy-based configs. GenericGroovyXmlContextLoader and GenericGroovyXmlWebContextLoader will detect classpath:com/example/MyTestContext.groovy. If we ommit the classes attribute the TestContext framework will attempt to detect the presence of default configuration classes. Specifically, AnnotationConfigContextLoader and AnnotationConfigWebContextLoader will detect all static nested classes of the test class that meet the requirements for configuration class implementations as specified in the @Configuration javadocs. 

@WebAppConfiguration is a class-level annotation that is used to declare that the ApplicationContext loaded for an integration test should be a WebApplicationContext. The mere presence of @WebAppConfiguration on a test class ensures that a WebApplicationContext will be loaded for the test, using the default value of "file:src/main/webapp" for the path to the root of the web application (i.e., the resource base path). The resource base path is used behind the scenes to create a MockServletContext which serves as the ServletContext for the test’s WebApplicationContext.
@WebAppConfiguration("classpath:test-web-resources") - both "classpath:..." and "file:..." resource prefixes are supported.
@WebAppConfiguration must be used in conjunction with @ContextConfiguration, either with a single test class or within a test class hierarchy.

In the background the TCF (TestContextFramework) makes sure that a MockServletContext is created and supplied to your test’s WAC (WebApplicationContext). By default the base resource path for your MockServletContext will be set to "src/main/webapp". This is interpreted as a path relative to the root of your JVM (i.e., normally the path to your project). If you’re familiar with the directory structure of a web application in a Maven project, you’ll know that "src/main/webapp" is the default location for the root of your WAR. If you need to override this default, simply provide an alternate path to the @WebAppConfiguration annotation (e.g., @WebAppConfiguration("src/test/webapp")). If you wish to reference a base resource path from the classpath instead of the file system, just use Spring’s classpath: prefix. By default, @WebAppConfiguration resource paths are file system based; whereas, @ContextConfiguration resource locations are classpath based.

To test request or session scoped beans we must ensure that WebApplicationContext is loaded for your test and inject the mock request or session into your test instance 

If your test class does not explicitly declare application context resource locations or annotated classes, the configured ContextLoader determines how to load a context from a default location or default configuration classes. In addition to context resource locations and annotated classes, an application context can also be configured via application context initializers.

To use transactions in a unit or integration test we need to use the @Transactional annotation on the class or method level and configure a PlatformTransactionManager bean in the ApplicationContext loaded with @ContextConfiguration.

There are three types of transactions when referring to tests:
- test-managed transactions - managed declaratively by TransactionalTestExecutionListener or programatically via TestTransaction.
- Spring-managed transactions - managed directly by the application context loaded for tests
- application-managed transactions - managed programatically via application code within tests
Spring-managed and application-managed transactions will typically participate in test-managed transactions; however, caution should be taken if Spring-managed or application-managed transactions are configured with any propagation type other than REQUIRED or SUPPORTS

Annotating a test method with @Transactional causes the test to be run within a transaction that will, by default, be automatically rolled back after completion of the test. If a test class is annotated with @Transactional, each test method within that class hierarchy will be run within a transaction.
Tests that are annotated with @Transactional but have the propagation type set to NOT_SUPPORTED will not be run within a transaction.

When using the J2EE transaction model, developers should not think in terms of starting and stopping transactions. Instead, developers should think about sections of sequential actions that should be enclosed in some sort of transactional behavior. This enclosing of transactional behavior is called transaction demarcation.
Transaction demarcation always wraps a sequence of actions, such as a single request, a single method, or a section of code within a method. The demarcation initializes some transactional behavior before the demarcated area begins, then ends that transactional behavior when the demarcated area ends. The application server uses these demarcations to determine the appropriate calls to the TransactionManager object.
Transaction demarcation determines where a transaction begins and ends

The TestTransaction utility class can be used to manipulate transactions within tests.

@ContextHierarchy is a class-level annotation that is used to define a hierarchy of ApplicationContexts for integration tests. @ContextHierarchy should be declared with a list of one or more @ContextConfiguration instances, each of which defines a level in the context hierarchy. @ContextHierarchy can also be used within a test class hierarchy.

If a context hierarchy is declared on multiple classes within a test class hierarchy it is also possible to merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration for a given level in the hierarchy the configuration resource type (i.e., XML configuration files or annotated classes) must be consistent; otherwise, it is perfectly acceptable to have different levels in a context hierarchy configured using different resource types.

Example:
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})

If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy, you must explicitly name that level by supplying the same value to the name attribute in @ContextConfiguration at each corresponding level in the class hierarchy.

@RunWith(SpringRunner.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
public class BaseTests {}

// the result here is that three contexts are loaded - the ones named "child" will be merged from the parent and child class
// we can set the inheritLocations value to false here to override the "child" context
@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
public class ExtendedTests extends BaseTests {}

The following test classes define a context hierarchy within a test class hierarchy. AbstractWebTests declares the configuration for a root WebApplicationContext in a Spring-powered web application. Note, however, that AbstractWebTests does not declare @ContextHierarchy; consequently, subclasses of AbstractWebTests can optionally participate in a context hierarchy or simply follow the standard semantics for @ContextConfiguration. SoapWebServiceTests and RestWebServiceTests both extend AbstractWebTests and define a context hierarchy via @ContextHierarchy. The result is that three application contexts will be loaded (one for each declaration of @ContextConfiguration), and the application context loaded based on the configuration in AbstractWebTests will be set as the parent context for each of the contexts loaded for the concrete subclasses.

@RunWith(SpringRunner.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml")
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml")
public class RestWebServiceTests extends AbstractWebTests {}

  *  http://docs.spring.io/spring-framework/docs/4.0.9.RELEASE/spring-framework-reference/html/testing.html#integration-testing-annotations-meta
Transaction management
  *  http://docs.spring.io/spring-framework/docs/4.0.9.RELEASE/spring-framework-reference/html/testing.html#testcontext-tx

TestPropertyValues - Test utilities for adding properties. Properties can be applied to a Spring Environment or to the system environment.

Spring includes a number of packages dedicated to mocking:
- Environment
- JNDI
- Servlet API
- Spring Web Reactive

out-of-container testing - writing unit or integration tests that test the controller logic with mocking the controller layer
end-to-end test - integration tests that include an actual web/application server
testing in isolation - testing without using a server

AbstractJUnit4SpringContextTest implements ApplicationContextAware and therefore provides access to the ApplicationContext automatically. It provides us with a protected applicationContext instance variable
that cacn be used to perform explicit bean lookups or to test the state of the context as a whole.

This is a valid usage of Mockito:
<bean id="myService" class="org.mockito.Mockito" factory-method="mock">
     <constructor-arg value="org.dummy.MyService"/>
</bean>

@RunWith is a JUnit annotation, not a Spring annotation.

@ActiveProfiles is a class-level annotation that is used to declare which bean definition profiles should be active when loading an ApplicationContext for an integration test.
@ActiveProfiles provides support for inheriting active bean definition profiles declared by superclasses by default. It is also possible to resolve active bean definition profiles programmatically by implementing a custom ActiveProfilesResolver and registering it via the resolver attribute of @ActiveProfiles. As of Spring Framework 4.0, this annotation may be used as a meta-annotation to create custom composed annotations. To register the resolver we need to pass the class to the "resolver" attribute of the @ActiveProfiles annotation. We can use the "inheritProfiles" attribute to set wether profiles should be inherited by parent classes. Set to "true" by default.

The TestContext framework can be instructed to cause the transaction to commit instead of roll back via the @Commit annotation.
The @Default annotation from JTA can also be used to specify this behavior.

In a test it is possible to set certain methods only to be ran under a transaction, by specifying the @Transactional annotation on the method level.

Those are 4 valid ways to create a shared application context:

- extend AbstractJUnit4SpringContextTest
@ContextConfiguration
public class MyTestClass extends AbstractJUnit4SpringContextTest { ... }
- autowire the application context
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class MyTestClass {
  @Autowired
  private ApplicationContext applicationContext;
}
- pass in XML or Java-based configs:
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration({"/conf1.xml", "/conf2.xml"})
// or @ContextConfiguration({Conf1.class, Conf2.class})
public class MyTestClass {...}

@TestPropertySource is a class-level annotation that is used to configure the locations of properties files and inlined properties to be added to the set of PropertySources in the Environment for an ApplicationContext loaded for an integration test.
Test property sources have higher precedence than those loaded from the operating system’s environment or Java system properties as well as property sources added by the application declaratively via @PropertySource or programmatically. Furthermore, inlined properties have higher precedence than properties loaded from resource locations.

@TestPropertySource("/test.properties")
@TestPropertySource({"timezone = GMT", "port: 4242" })

If @TestPropertySource is declared as an empty annotation (i.e., without explicit values for the locations or properties attributes), an attempt will be made to detect a default properties file relative to the class that declared the annotation. For example, if the annotated test class is com.example.MyTest, the corresponding default properties file is "classpath:com/example/MyTest.properties". If the default cannot be detected, an IllegalStateException will be thrown.

If you are extending from a Spring-provided test base class that happens to use @Autowired on one of its setter methods, you might have multiple beans of the affected type defined in your application context: for example, multiple DataSource beans. In such a case, you can override the setter method and use the @Qualifier annotation to indicate a specific target bean as follows, but make sure to delegate to the overridden method in the superclass as well.

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

The specified qualifier value indicates the specific DataSource bean to inject, narrowing the set of type matches to a specific bean. Its value is matched against <qualifier> declarations within the corresponding <bean> definitions. The bean name is used as a fallback qualifier value, so you may effectively also point to a specific bean by name there (as shown above, assuming that "myDataSource" is the bean id).

@DirtiesContext indicates that the underlying Spring ApplicationContext has been dirtied during the execution of a test (i.e., modified or corrupted in some manner — for example, by changing the state of a singleton bean) and should be closed. When an application context is marked dirty, it is removed from the testing framework’s cache and closed. As a consequence, the underlying Spring container will be rebuilt for any subsequent test that requires a context with the same configuration metadata. @DirtiesContext can be used as both a class-level and method-level annotation within the same class or class hierarchy.
In such scenarios, the ApplicationContext is marked as dirty before or after any such annotated method as well as before or after the current test class, depending on the configured methodMode and classMode.
@DirtiesContext(classMode = BEFORE_CLASS)
@DirtiesContext ( same as @DirtiesContext(classMode = AFTER_CLASS), e.g. the default classMode)
@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)
@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)
@DirtiesContext(methodMode = BEFORE_METHOD)
@DirtiesContext(methodMode = AFTER_METHOD) // this is the default method mode

If @DirtiesContext is used in a test whose context is configured as part of a context hierarchy via @ContextHierarchy, the hierarchyMode flag can be used to control how the context cache is cleared.
By default an exhaustive algorithm will be used that clears the context cache including not only the current level but also all other context hierarchies that share an ancestor context common to the current test; all ApplicationContexts that reside in a sub-hierarchy of the common ancestor context will be removed from the context cache and closed. If the exhaustive algorithm is overkill for a particular use case, the simpler current level algorithm can be specified.
DirtiesContext.HierarchyMode.CURRENT_LEVEL
DirtiesContext.HierarchyMode.EXHAUSTIVE

@TestExecutionListeners defines class-level metadata for configuring the TestExecutionListener implementations that should be registered with the TestContextManager. Typically, @TestExecutionListeners is used in conjunction with @ContextConfiguration.

@Commit can be annotated on the class-level as well as method level annotation. It indicates that the transaction for a transactional test method should be commited after the test method has completed. @Commit can be used as a direct replacement for @Rollback(false) in order to more explicitly convey the intent of the code.

@Rollback indicates whether the transaction for a transactional test method should be rolled back after the test method has completed. If true, the transaction is rolled back; otherwise, the transaction is committed (see also @Commit). Rollback semantics for integration tests in the Spring TestContext Framework default to true even if @Rollback is not explicitly declared. When declared as a class-level annotation, @Rollback defines the default rollback semantics for all test methods within the test class hierarchy. When declared as a method-level annotation, @Rollback defines rollback semantics for the specific test method, potentially overriding class-level @Rollback or @Commit semantics.

@BeforeTransaction indicates that the annotated void method should be executed before a transaction is started for test methods configured to run within a transaction via Spring’s @Transactional annotation. As of Spring Framework 4.3, @BeforeTransaction methods are not required to be public and may be declared on Java 8 based interface default methods.

@AfterTransaction indicates that the annotated void method should be executed after a transaction is ended for test methods configured to run within a transaction via Spring’s @Transactional annotation. As of Spring Framework 4.3, @AfterTransaction methods are not required to be public and may be declared on Java 8 based interface default methods.

@BeforeTransaction and @AfterTransaction can also be used within test interfaces.

Any before methods (such as methods annotated with JUnit Jupiter’s @BeforeEach) and any after methods (such as methods annotated with JUnit Jupiter’s @AfterEach) are executed within a transaction. In addition, methods annotated with @BeforeTransaction or @AfterTransaction are naturally not executed for test methods that are not configured to run within a transaction.

TransactionalTestExecutionListener expects a PlatformTransactionManager bean to be defined in the Spring ApplicationContext for the test. In case there are multiple instances of PlatformTransactionManager within the test’s ApplicationContext, a qualifier may be declared via @Transactional("myTxMgr") or @Transactional(transactionManager = "myTxMgr"), or TransactionManagementConfigurer can be implemented by an @Configuration class.

@Sql is used to annotate a test class or test method to configure SQL scripts to be executed against a given database during integration tests. @SqlConfig is used to annotate a test class or test method to configure SQL scripts to be executed against a given database during integration tests.
Since Java 8 @Sql can be used as a repeatable annotation. Otherwise, @SqlGroup can be used as a container to explicitly declare multiple instances of @Sql.
@Sql({"/test-schema.sql", "/test-user-data.sql"})
By default @Sql scripts are executed before a test method. They can be set to be executed after the method with the "executionPhase = AFITER_TEST_METHOD" attribute
If no SQL scripts are specified, an attempt will be made to detect a default script depending on where @Sql is declared. If a default cannot be detected, an IllegalStateException will be thrown.
class-level declaration: if the annotated test class is com.example.MyTest, the corresponding default script is "classpath:com/example/MyTest.sql".
method-level declaration: if the annotated test method is named testMethod() and is defined in the class com.example.MyTest, the corresponding default script is "classpath:com/example/MyTest.testMethod.sql".

@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@")
)

@SqlConfig defines metadata that is used to determine how to parse and execute SQL scripts configured via the @Sql annotation. When declared as a class-level annotation on an integration test class, @SqlConfig serves as global configuration for all SQL scripts within the test class hierarchy. When declared directly via the config attribute of the @Sql annotation, @SqlConfig serves as local configuration for the SQL scripts declared within the enclosing @Sql annotation.
If the algorithms used by SqlScriptsTestExecutionListener to detect a DataSource and PlatformTransactionManager and infer the transaction semantics do not suit your needs, you may specify explicit names via the dataSource and transactionManager attributes of @SqlConfig. The transaction propagation can be controlled via the transactionMode attribute of @SqlConfig.

The configuration options provided by @Sql and @SqlConfig are a superset of those provided by the <jdbc:initialize-database/> XML namespace element.

Regarding transactions and the execution of SQL scripts with @Sql:
 Specifically, SQL scripts will be executed without a transaction, within an existing Spring-managed transaction — for example, a transaction managed by the TransactionalTestExecutionListener for a test annotated with @Transactional — or within an isolated transaction, depending on the configured value of the transactionMode attribute in @SqlConfig and the presence of a PlatformTransactionManager in the test’s ApplicationContext. As a bare minimum however, a javax.sql.DataSource must be present in the test’s ApplicationContext. As a bare minimum however, a javax.sql.DataSource must be present in the test’s ApplicationContext.

@SqlGroup is a container annotation that aggregates several @Sql annotations. @SqlGroup can be used natively, declaring several nested @Sql annotations.

The following annotations are supported with standard semantics for all configurations of the Spring TestContext Framework:
@Autowired
@Qualifier
@Resource (javax.annotation) if JSR-250 is present
@ManagedBean (javax.annotation) if JSR-250 is present
@Inject (javax.inject) if JSR-330 is present
@Named (javax.inject) if JSR-330 is present
@PersistenceContext (javax.persistence) if JPA is present
@PersistenceUnit (javax.persistence) if JPA is present
@Required
@Transactional

As of Spring 3.1, ContextLoaderListener supports injecting the root web application context via the ContextLoaderListener(WebApplicationContext) constructor, allowing for programmatic configuration in Servlet 3.0+ environments.

The org.pspringframework.test.jdbc package contains JdbcTestUtils, which is a utility class to simplify standard database testing scenarios.
JdbcTestUtils provides the following static utility methods:
- countRowsInTable(..) - counts the number of rows in the given table
- countRowsInTableWhere(...) - counts the number of rows in the given table, using the provided WHERE clause
- deleteFromTables(...) - deletes all rows from the specified tables
- deleteFromTableWhere(...) - delete rows from the given table, using the provided WHERE clause
- dropTables(...) - drops the specified tables

Note that AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests provide convenience methods
which delegate to the aforementioned methods in JdbcTestUtils. They are configured for transactional support at the class-level.

These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using @RunWith(SpringRunner.class) or Spring’s JUnit rules.

Spring provides the following options for executing SQL scripts programmatically within integration test methods.
- org.springframework.jdbc.datasource.init.ScriptUtils - provides a collection of static utility methods for working wih SQL scripts and is mainly intended for internal use within the framework
- org.springframework.jdbc.datasource.init.ResourceDatabasePopulator - provides a simple object-based API for programmatically populating, initializing, or cleaning up a database using SQL scripts defined in external resources. ResourceDatabasePopulator provides options for configuring the character encoding, statement separator, comment delimiters, and error handling flags used when parsing and executing the scripts, and each of the configuration options has a reasonable default value. To execute the scripts configured in a ResourceDatabasePopulator, you can invoke either the populate(Connection) method to execute the populator against a java.sql.Connection or the execute(DataSource) method to execute the populator against a javax.sql.DataSource.
- org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests
- org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests

The following annotations are only supported when used in conjunction with the SpringRunner, Spring’s JUnit 4 rules, or Spring’s JUnit 4 support classes.
@IfProfileValue - indicates that the annotated test is enabled for a secific testing environment. If the configured ProfileValueSource returns a matching value for the provided name, the test is enabled. Otherwise, the test will be disabled and effectively ignored. @IfProfileValue can be applied at the class level, the method level, or both. Class-level usage of @IfProfileValue takes precedence over method-level usage for any methods within that class or its subclasses. Specifically, a test is enabled if it is enabled both at the class level and at the method level; the absence of @IfProfileValue means the test is implicitly enabled. 
@ProfileValueSourceConfiguration is a class-level annotation that specifies what type of ProfileValueSource to use when retrieving profile values configured through the @IfProfileValue annotation. If @ProfileValueSourceConfiguration is not declared for a test, SystemProfileValueSource is used by default.
@Timed indicates that the annotated test method must finish execution in a specified time period (in milliseconds). If the text execution time exceeds the specified time period, the test fails. The time period includes execution of the test method itself, any repetitions of the test (see @Repeat), as well as any set up or tear down of the test fixture.
@Timed(millis=1000)
Spring's @Timed annotation has different semantics than JUnit 4's @Timed. Spring's implementations waits for the test to finish, while the JUnit4 one preemptively fails the test if he test takes oo long.
@Repeat indicates that the annotated test method must be executed repeatedly. The number of times that the test method is to be executed is specified in the annotation.
The scope of execution to be repeated includes execution of the test method itself as well as any set up or tear down of the test fixture.

The following annotations are only supported when used in conjunction with the SpringExtetnsion and JUnit Jupiter (JUnit 5):
@SpringJUnitConfig combines @ExtendWith(SpringExtension.class) from JUnitt Jupiter with @ContextConfiguration from the Spring TextContext Framework.
@SpringJUnitConfig(TestConfig.class)
@SpringJUnitConfig(locations = "/text-config.xml")

@SpringJUnitWebConfig is a composed annotation that combines @ExtendWith(SpringExtension.class) from JUnit Jupiter with @ContextConfiguration and @WebAppConfiguration from the Spring TestContext Framework. It can be used at the class level as a drop-in replacement for @ContextConfiguration and @WebAppConfiguration. the only difference between @ContextConfiguration and @SpringJUnitWebConfig is that annotated classes may be declared via the value attribute in @SpringJUnitWebConfig. In addition, the value attribute from @WebAppConfiguration can only be overridden via the resourcePath attribute in @SpringJUnitWebConfig
@EnableIf - used to signal that the annotated JUnit Jupiter test class or test method is enabled of the provided SpEL expression or environment property or text literal evaluates to true. @EnableIf can be used to create meta annotations
@DisableIf - used to signal that the annotated JUnit Jupiter test class or test method is disabled of the provided SpEL expression or environment property or text literal evaluates to true. @DisableIf can be used to create meta annotations

The org.springframework.test.context.junit4.rules package provides the following JUnit 4 rules (supported on JUnit 4.12 or higher).
- SpringClassRule
- SpringMethodRule

In contrast to the SpringRunner, Spring’s rule-based JUnit support has the advantage that it is independent of any org.junit.runner.Runner implementation and can therefore be combined with existing alternative runners like JUnit 4’s Parameterized or third-party runners such as the MockitoJUnitRunner.

Each of the following may be used as meta-annotations in conjunction with the TestContext framework.
@BootstrapWith ,@ContextConfiguration ,@ContextHierarchy ,@ActiveProfiles ,@TestPropertySource ,@DirtiesContext ,@WebAppConfiguration ,@TestExecutionListeners ,@Transactional ,@BeforeTransaction ,@AfterTransaction ,@Commit ,@Rollback ,@Sql ,@SqlConfig ,@SqlGroup ,@Repeat (only supported on JUnit 4) ,@Timed (only supported on JUnit 4) ,@IfProfileValue (only supported on JUnit 4) ,@ProfileValueSourceConfiguration (only supported on JUnit 4) ,@SpringJUnitConfig (only supported on JUnit Jupiter) ,@SpringJUnitWebConfig (only supported on JUnit Jupiter) ,@EnabledIf (only supported on JUnit Jupiter) ,@DisabledIf (only supported on JUnit Jupiter)

Since JUnit Jupiter supports the use of @Test, @RepeatedTest, ParameterizedTest, etc. as meta-annotations, it is also possible to create custom composed annotations at the test method level.

The SpringExtension implements the ParameterResolver extension API from JUnit Jupiter which allows Spring to provide dependency injection for test constructors, test methods and test lifecycle callback methods.
Specifically, the SpringExtension is able to inject dependencies from the test’s ApplicationContext into test constructors and methods annotated with @BeforeAll, @AfterAll, @BeforeEach, @AfterEach, @Test, @RepeatedTest, @ParameterizedTest, etc.

If a parameter in a constructor for a JUnit Jupiter test class is of type ApplicationContext (or a sub-type thereof) or is annotated or meta-annotated with @Autowired, @Qualifier, or @Value, Spring will inject the value for that specific parameter with the corresponding bean from the test’s ApplicationContext.

The org.springframework.test.context.testng package provides the following support classes for TestNG:
AbstractTestNGSpringContextTests
AbstractTransactionalTestNGSpringContextTests - behaves the same as the JUnit 4 equivalent

The core of the Spring TextContext framework consists of the TextContextManager class, TextContext, TestExecutionListener and SmartContextLoader.
TestContext - encapsulates the context in which a test is executed, agnostic of the actual testing framework in use, and provides context management and caching support for the test instance for which it is responsible. The TestContext also delegates to a SmartContextLoader to load an ApplicationContext if requested.

TestContextManager is the main entry point into the Spring TestContext Framework and is responsible for managing a single TestContext and signaling events to each registered TestExecutionListener at well-defined test execution points.
- prior to any before class or before all methods of a particular testing framework
- test instance post-processing
- prior to any before or before each methods of a particular testing framework
- immediately before execution of the test method but after test setup
- immediately after execution of the test method but before test tear down
- after any after or after each methods of a particular testing framework
- after any after class or after all methods of a particular testing framework

TestExecutionListener defines the API for reacting to test execution events published by the TestContextManager with which the listener is registered.

Spring provides the following TestExecutionListener implementations that are registered by default, exactly in this order.
ServletTestExecutionListener: configures Servlet API mocks for a WebApplicationContext
DirtiesContextBeforeModesTestExecutionListener: handles the @DirtiesContext annotation for before modes
DependencyInjectionTestExecutionListener: provides dependency injection for the test instance
DirtiesContextTestExecutionListener: handles the @DirtiesContext annotation for after modes
TransactionalTestExecutionListener: provides transactional test execution with default rollback semantics
SqlScriptsTestExecutionListener: executes SQL scripts configured via the @Sql annotation

ContextLoader is a strategy interface that was introduced in Spring 2.5 for loading an ApplicationContext for an integration test managed by the Spring TestContext Framework. 

SmartContextLoader is an extension of the ContextLoader interface introduced in Spring 3.1. The SmartContextLoader SPI supersedes the ContextLoader SPI that was introduced in Spring 2.5. Specifically, a SmartContextLoader can choose to process resource locations, annotated classes, or context initializers. Furthermore, a SmartContextLoader can set active bean definition profiles and test property sources in the context that it loads.

TestContextBootstrapper defines the SPI for bootstrapping the TestContext framework. A TestContextBootstrapper is used by the TestContextManager to load the TestExecutionListener implementations for the current test and to build the TestContext that it manages. A custom bootstrapping strategy can be configured for a test class (or test class hierarchy) via @BootstrapWith, either directly or as a meta-annotation. If a bootstrapper is not explicitly configured via @BootstrapWith, either the DefaultTestContextBootstrapper or the WebTestContextBootstrapper will be used, depending on the presence of @WebAppConfiguration.

Each TestContext provides context management and caching support for the test instance it is responsible for. Test instances do not automatically receive access to the configured ApplicationContext. However, if a test class implements the ApplicationContextAware interface, a reference to the ApplicationContext is supplied to the test instance. Note that AbstractJUnit4SpringContextTests and AbstractTestNGSpringContextTests implement ApplicationContextAware and therefore provide access to the ApplicationContext automatically.

As an alternative to implementing the ApplicationContextAware interface, the application context for the test class can be injected through the @Autowired annotation on either a field or a setter method:

@RunWith(SpringRunner.class)
@ContextConfiguration
public class MyTest {

	@Autowired
	private ApplicationContext applicationCtx;
	// class body
}

Similarly, a WebApplicationContext could be configured:
@RunWith(SpringRunner.class)
@WebAppConfiguration
@ContextConfiguration
public class MyWebAppTest {
	@Autowired
	private WebApplicationContext webAppCtx;
	//class body
}

Do not execute tests in parallel if:

Tests make use of Spring’s @DirtiesContext support.
Tests make use of JUnit 4’s @FixMethodOrder support or any testing framework feature that is designed to ensure that test methods execute in a particular order. Note, however, that this does not apply if entire test classes are executed in parallel.
Tests change the state of shared services or systems such as a database, message broker, filesystem, etc. This applies to both in-memory and external systems. If the maximum size of the ContextCache has been exceeded, you can increase the maximum size of the cache.

If parallel test execution fails with an exception stating that the ApplicationContext for the current test is no longer active, this typically means that the ApplicationContext was removed from the ContextCache in a different thread.

Spring provides integration between MockMvc and HtmlUnit. This simplifies performing end-to-end testing when using HTML-based views. This integration lets you:
- Easily test HTML pages by using tools such as HtmlUnit, WebDriver, and Geb without the need to deploy to a Servlet container.
- Test JavaScript within pages.
- Optionally, test using mock services to speed up testing.
- Share logic between in-container end-to-end tests and out-of-container integration tests.

MockMvc works with templating technologies that do not rely on a Servlet Container (for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since they rely on the Servlet container.

To use HtmlUnit the following dependency needs to be added: net.sourceforge.htmlunit:htmlunit. In order to use HtmlUnit with Apache HttpComponents 4.5+, you need to use HtmlUnit 2.18 or higher.

We can easily create an HtmlUnit WebClient that integrates with MockMvc by using the MockMvcWebClientBuilder, as follows:
@Autowired
WebApplicationContext context;

WebClient webClient;

@Before
public void setup() {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}

HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");
HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();

assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");

HtmlUnit uses the Mozilla Rhino engine to evaluate JS code.

//we can also specify additional configuration as the following example shows:
WebClient webClient;

@Before
public void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}

//As an alternative, we can perform the exact same setup by configuring the MockMvc instance separately and supplying it to the MockMvcWebClientBuilder
MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();

To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project includes a test dependency on org.seleniumhq.selenium:selenium-htmlunit-driver.

// sample of testing a REST call
RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer
										.bindTo(restTemplate)
										.ignoreExpectOrder(true) // set to true if you would like to make the request in any order; By default, requests are expected in the order in which expectations were declared.
										.build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());
// Test code that uses the above RestTemplate ...
mockServer.verify();

The expect method provides an overloaded variant that accepts an ExpectedCount argument that specifies a count range (for example, once, manyTimes, max, min, between, and so on). The following example uses times:
MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

WebTestClient is a thin shell around WebClient, using it to perform requests and exposing a dedicated, fluent API for verifying responses. WebTestClient binds to a WebFlux application by using a mock request and response, or it can test any web server over an HTTP connection.

client = WebTestClient.bindToController(new TestController()).build()

WebTestClient provides an API identical to WebClient up to the point of performing a request by using exchange(). What follows after exchange() is a chained API workflow to verify responses.
    client.get().uri("/persons/1")
        .accept(MediaType.APPLICATION_JSON_UTF8)
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8)

//methods for asserting the body
expectBody(Class<T>): Decode to single object.
expectBodyList(Class<T>): Decode and collect objects to List<T>.
expectBody(): Decode to byte[] for JSON Content or an empty body.
	...
	.expectBodyList(Person.class).hasSize(3).contains(person)
	.consumeWith(result -> {
		//custom assertions (e.g. AssertJ)
	})
	.returnResult(); //we can call the returnResult() in the method chain and return a EntityExchangeResult<Person>.

	...
	.expectBody(Void.class) - we can use this syntax if we expect the body to be empty (or not care about the body content)
	//or
	.expectBody()
	.isEmpty()

	//use JSONAssert to assert that the response body matches a JSON String
	.expectBody()
	.json(""{\"name\":\"Jane\"}")

	//use JSON path
	client.get().uri("/persons")
		.exchange()
		.expectStatus().isOk()
		.expectBody()
		.jsonPath("$[0].name").isEqualTo("Jane")
		.jsonPath("$[1].name").isEqualTo("Jason")

To test infinite streams (for example, "text/event-stream" or "application/stream+json"), you need to exit the chained API (by using returnResult),

FluxExchangeResult<MyEvent> result = client.get().uri("/events")
	.accept(TEXT_EVENT_STREAM)
	.exchange()
	.expectStatus().isOk()
	.returnResult(MyEvent.class)

    Flux<Event> eventFux = result.getResponseBody();

    StepVerifier.create(eventFlux)
            .expectNext(person)
            .expectNextCount(4)
            .consumeNextWith(p -> ...)
            .thenCancel()
            .verify()

-- Spring Security

https://spring.io/guides/topicals/spring-security-architecture/

Example Spring security annotations (all 4 can use SPeL):
@PreAuthorize
@PreFilter
@PostAuthorize
@PostFilter

List of Spring Security dependencies: spring-security-core.jar, spring-security-remoting.jar, spring-security-web.jar, spring-security-config.jar, spring-security-ldap.jar, spring-security-oauth2-core.jar,   spring-security-oauth2-client.jar, spring-security-oauth2-jose.jar, spring-security-acl.jar,  spring-security-cas.jar,   spring-security-openid.jar, spring-security-test.jar, spring-security-oauth2-resource-server.jar

"You can use multiple <intercept-url> elements to define different access requirements for different sets of URLs, but they will be evaluated in the order listed and the first match will be used. So you must put the most specific matches at the top. You can also add a method attribute to limit the match to a particular HTTP method (GET, POST, PUT etc.)."

The following are true regarding the XML tag in Spring Security used in pages to determine wether its contents should be evaluated or not:
The 'authorize' tag is used to determine whether its contents should be evaluated or not. 
The 'authentication' tag allows access to the current Authentication object stored in the security context. 
The 'accesscontrollist' tag is only valid when used with Spring Security's ACL module.
There is no 'authenticated' XML tag for this purpose.

Spring secures method invocations using Spring AOP.
Spring secures web requests using standard filters

In Spring security, which of these is the attribute of the 'intercept-url' element which can cause any matching request to bypass the filter chain entirely?
- filter

"Another item to note from the above code fragment is that you can obtain a principal from the Authentication object. The principal is just an Object. Most of the time this can be cast into a UserDetails object. UserDetails is a core interface in Spring Security. It represents a principal, but in an extensible and application-specific way. Think of UserDetails as the adapter between your own user database and what Spring Security needs inside the SecurityContextHolder. Being a representation of something from your own user database, quite often you will cast the UserDetails to the original object that your application provided, so you can call business-specific methods (like getEmail(), getEmployeeNumber() and so on). On successful authentication, UserDetails is used to build the Authentication object that is stored in the SecurityContextHolder (more on this below)."

The SecurityContext object contains an Authentication object. It is contained in the SecurityContextHolder.

<filter-chain> is used to set up security filter chains.  It includes an attribute where you can specify the filters that you prefer to use.
FilterChainProxy is a Filter  (implements Java's Filter interface).
<intercept-url> can be used to define URL patterns and how they should be handled.

Below is an example from the Spring Security Reference depicting the purpose of the requires-channel attribute:
     <http>
          <intercept-url pattern="/secure/**" access="ROLE_USER" requires-channel="https"></intercept>
          <intercept-url pattern="/**" access="ROLE_USER" requires-channel="any"></intercept>
          ...
     </http>

The 'requires-channel' can be set to 'https' to enforce HTTPS channel security.  The other possible values are 'http' and 'any'.
Below is an example.
     <intercept-url pattern="/**" access="authenticated" requires-channel="https"></intercept>

You can use multiple <intercept-url> elements to define different access requirements for different sets of URLs, but they will be evaluated in the order listed and the first match will be used. So you must put the most specific matches at the top. You can also add a method attribute to limit the match to a particular HTTP method (GET, POST, PUT etc.).

Spring secures method invocations, not web requests, using Spring AOP. Web requests in Spring security use filter chains.

Explanation
The Spring Security Reference says:
     "'filters' can only take the value "none".  This will cause any matching request to bypass the Spring Security filter chain entirely.  None of the rest of the &lt;http&gt; configuration will have any effect on the request and there will be no security context available for its duration. Access to secured methods during the request will fail."
Below is an example.
     &lt;intercept-url pattern="/**" access="ROLE_USER" filters="none" &gt;&lt;/intercept&gt;
The 'security' attribute of the 'http' element is able to do something similar to what filters="none" does.  Below is an example.
     &lt;http pattern="/css/**" security="none"&gt;&lt;/http&gt;
The Spring Security Reference describes the 'security' attribute as:
     "A request pattern can be mapped to an empty filter chain, by setting this attribute to none. No security will be applied and none of Spring Security's features will be available."
Reference
2.1.18. 
  *  http://docs.spring.io/spring-security/site/docs/3.2.5.RELEASE/reference/htmlsingle/#nsa-intercept-url
  *  Appendix
  *  Spring Security Reference, Version 3.2.5.RELEASE

Explanation:
The Spring Security Reference says:
     'Spring Security's PasswordEncoder interface is used to support the use of passwords which are encoded in some way in persistent storage.'
The Spring Security Reference says:
     'A hash is "one-way" in the sense that it is very difficult (effectively impossible) to obtain the original input given the hash value, or indeed any possible input which would produce that hash value. This property makes hash values very useful for authentication purposes. They can be stored in your user database as an alternative to plaintext passwords and even if the values are compromised they do not immediately reveal a password which can be used to login. Note that this also means you have no way of recovering the password once it is encoded.'
Reference
2.3. Password Encoding
  *  http://docs.spring.io/spring-security/site/docs/3.2.5.RELEASE/reference/htmlsingle/#core-services-password-encoding
  *  Architecture and Implementation
  *  Spring Security Reference, Version 3.2.5.RELEASE

We can enable the @Secured annotation in the following way:
<global-method-security secured-annotations="enabled"/>

Below is an example of a DelegatingFilterProxy declaration
     <filter>
          <filter-name>aFilter</filter-name>
          <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
     </filter>
     <filter-mapping>
          <filter-name>aFilter</filter-name>
          <url-pattern>/*</url-pattern>
     </filter-mapping>

-- Spring Boot

The SpringApplication class provides a convenient way to bootstrap a Spring application that is started from a main() method. In many situations, you can delegate to the static SpringApplication.run method, as shown in the following example:

public static void main(String[] args) {
	SpringApplication.run(MySpringConfiguration.class, args);
}

https://github.com/spring-projects/spring-boot/tree/v2.1.8.RELEASE/spring-boot-samples
https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html

spring.profiles.active - this property can be used to specify the active profiles

META-INF/spring.factories - This file maps a name to different configuration classes which Spring Boot will try to run. Spring Boot starters should contain that file. Whether or not these classes will actually run will depend on the presence of dependent classes on the classpath.

We can include profiles in the following YAML syntax
spring.profiles: prod
spring.profiles.include:
	- proddb
	- prodmq
When running an application containing this in its application.yaml file the proddb and prodmq profiles are also activated when starting it up with --spring.profiles.active=prod
ConfigurableEnvironment - an interface implemented by all Environment types. Provides facilities  for setting active and default profiles and manipulating underlying property sources.

If your application fails to start, registered org.springframework.boot.diagnostics.FailureAnalyzers get a chance to provide a dedicated error message and a concrete action to fix the problem. They accept an org.springframework.boot.diagnostics.FailureAnalysis. If you need access to the BeanFactory or the Environment, your FailureAnalyzer can simply implement BeanFactoryAware or EnvironmentAware respectively.
FailureAnalyzer implementations must be registered in META-INF/spring.factories. Here's an example for this:
org.springframework.boot.diagnostics.FailureAnalyzer=com.example.ProjectConstarintViolationFailureAnalyzer

If no failure analyzers are able to handle the exception, you can still display the full conditions report to better understand what went wrong. To do so, you need to enable the debug property or enable DEBUG logging for org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener.
For instance, if you are running your application by using java -jar, you can enable the debug property as follows:
$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug

Short command line arguments can be used (--port=9000 instead of --server.port=9000). This can be achieved with the following line in application.properties:
server.port=${port:8080}

Application events are sent in the following order, as your application runs:

An ApplicationStartingEvent is sent at the start of a run but before any processing, except for the registration of listeners and initializers.
An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the context is known but before the context is created.
An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions have been loaded.
An ApplicationStartedEvent is sent after the context has been refreshed but before any application and command-line runners have been called.
An ApplicationReadyEvent is sent after any application and command-line runners have been called. It indicates that the application is ready to service requests.
An ApplicationFailedEvent is sent if there is an exception on startup.

We can register custom events with the following two methods:
SpringApplication.addListeners(...)
SpringApplicationBuilder.listeners(...)

You can programmatically set active profiles in Spring Boot by calling SpringApplication.setAdditionalProfiles(...) before your application runs. It is also possible to activate profiles by using Spring’s ConfigurableEnvironment interface.
ConfigurableEnvironment interface has the following methods:
- addActiveProfile(String profile)
- getPropertySources()
- getSystemEnvironment()
- getSystemProperties()
- merge(ConfigurableEnvironment parent)
- setActiveProfiles(String... profiles)
- setDefaultProfiles(String... profiles)

Application events are sent by using Spring Framework’s event publishing mechanism. Part of this mechanism ensures that an event published to the listeners in a child context is also published to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy of SpringApplication instances, a listener may receive multiple instances of the same type of application event.
To allow your listener to distinguish between an event for its context and an event for a descendant context, it should request that its application context is injected and then compare the injected context with the context of the event. The context can be injected by implementing ApplicationContextAware or, if the listener is a bean, by using @Autowired.

If you need to access the application arguments that were passed to SpringApplication.run(...), you can inject a org.springframework.boot.ApplicationArguments bean. The ApplicationArguments interface provides access to both the raw String[] arguments as well as parsed option and non-option arguments.

@Autowired
public MyBean(ApplicationArguments args) {
	boolean debug = args.containsOption("debug");
	List<String> files = args.getNonOptionArgs();
	// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
}

Spring Boot also registers a CommandLinePropertySource with the Spring Environment. This lets you also inject single application arguments by using the @Value annotation.

@ConfigurationProperties - annotation for externalized configuration. Add this to a class definition or a @Bean method in a @Configuration class if you want to bind and validate some external Properties (e.g. from a .properties file). Classes annotated with this annotation became beans themselves and can be autowired in classes annotated with @EnableConfigurationProperties
Note that contrary to @Value, SpEL expressions are not evaluated since property values are externalized.
@EnableConfigurationProperties(AcmeProperties.class) 
When the @ConfigurationProperties bean is registered that way, the bean has a conventional name: <prefix>-<fqn>, where <prefix> is the environment key prefix specified in the @ConfigurationProperties annotation and <fqn> is the fully qualified name of the bean. If the annotation does not provide any prefix, only the fully qualified name of the bean is used. If the prefix specified with the @ConfigurationProperties annotation in AcmeProperties is "my" the FQN of the bean will be my-com.example.AcmeProperties
@EnableConfigurationProperties annotation is also automatically applied to your project so that any existing bean annotated with @ConfigurationProperties is configured from the Environment

For example:
@ConfigurationProperties(prefix="my")
public class Config {
	private List<String> servers = new ArrayList<String>();
	public List<String> getServers() {
		return this.servers;
	}
}

This usage inject the following values into the servers collection:
my.servers[0]=dev,example.com
my.servers[1]=another.example.com

If you need to run some specific code once the SpringApplication has started, you can implement the ApplicationRunner or CommandLineRunner interfaces. Both interfaces work in the same way and offer a single run method, which is called just before SpringApplication.run(...) completes.

The CommandLineRunner interfaces provides access to application arguments as a simple string array, whereas the ApplicationRunner uses the ApplicationArguments interface discussed earlier. 

A SpringApplication attempts to create the right type of ApplicationContext on your behalf. The algorithm used to determine a WebApplicationType is fairly simple:

If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is used
If Spring MVC is not present and Spring WebFlux is present, an AnnotationConfigReactiveWebServerApplicationContext is used
Otherwise, AnnotationConfigApplicationContext is used
If you need to build an ApplicationContext hierarchy (multiple contexts with a parent/child relationship) or if you prefer using a “fluent” builder API, you can use the SpringApplicationBuilder.
The SpringApplicationBuilder lets you chain together multiple method calls and includes parent and child methods that let you create a hierarchy, as shown in the following example:

new SpringApplicationBuilder()
		.sources(Parent.class)
		.child(Application.class)
		.bannerMode(Banner.Mode.OFF)
		.run(args);

There are some restrictions when creating an ApplicationContext hierarchy. For example, Web components must be contained within the child context, and the same Environment is used for both parent and child contexts.

Each SpringApplication registers a shutdown hook with the JVM to ensure that the ApplicationContext closes gracefully on exit. All the standard Spring lifecycle callbacks (such as the DisposableBean interface or the @PreDestroy annotation) can be used.  In addition, beans may implement the org.springframework.boot.ExitCodeGenerator interface if they wish to return a specific exit code when SpringApplication.exit() is called. Also, the ExitCodeGenerator interface may be implemented by exceptions. When such an exception is encountered, Spring Boot returns the exit code provided by the implemented getExitCode() method.

SpringApplicationAdminMXBean - An MBean contract to control and monitor a running SpringApplication via JMX. Intended for internal use only

It is a good practise to locate the main application class in a Spring Boot application in a root package above other classes.  The @SpringBootApplication annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items.
Spring boot favors Java-based configuration although XML is still supported.
Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added.  For example, if HSQLDB 
is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.

Spring Boot can automatically create the schema (DDL scripts) of your DataSource and initialize it (DML scripts). It loads SQL from the standard root classpath locations: schema.sql and data.sql, respectively. In addition, Spring Boot processes the schema-${platform}.sql and data-${platform}.sql files (if present), where platform is the value of spring.datasource.platform. This allows you to switch to database-specific scripts if necessary. For example, you might choose to set it to the vendor name of the database (hsqldb, h2, oracle, mysql, postgresql, and so on).

Spring Boot supports two higher-level migration tools: Flyway and Liquibase.

Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. 
For example, if you add your own DataSource bean, the default embedded database support backs away.

If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch (or -Ddebug when running the Maven Spring Boot plugin). Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console.

There is a really useful ConditionEvaluationReport available in any Spring Boot ApplicationContext. You can see it if you enable DEBUG logging output. If you use the spring-boot-actuator (see the Actuator chapter), there is also a conditions endpoint that renders the report in JSON. Use that endpoint to debug the application and see what features have been added (and which have not been added) by Spring Boot at runtime.

A running application with the Actuator features has a configprops endpoint that shows all the bound and bindable properties available through @ConfigurationProperties.

Troubleshooting tips and tricks:
- Look for classes called *AutoConfiguration and read their sources. Pay special attention to the @Conditional* annotations to find out what features they enable and when. Look for classes called *AutoConfiguration and read their sources. Pay special attention to the @Conditional* annotations to find out what features they enable and when. 
- Look for uses of the bind method on the Binder to pull configuration values explicitly out of the Environment in a relaxed manner. It is often used with a prefix.
- Look for @Value annotations that bind directly to the Environment.
- Look for @ConditionalOnExpression annotations that switch features on and off in response to SpEL expressions, normally evaluated with placeholders resolved from the Environment.
- Look for classes that are @ConfigurationProperties (such as ServerProperties) and read from there the available external configuration options. The @ConfigurationProperties annotation has a name attribute that acts as a prefix to external properties. Thus, ServerProperties has prefix="server" and its configuration properties are server.port, server.address, and others. In a running application with actuator enabled, look at the configprops endpoint.

A SpringApplication has ApplicationListeners and ApplicationContextInitializers that are used to apply customizations to the context or environment. Spring Boot loads a number of such customizations for use internally from META-INF/spring.factories. There is more than one way to register additional customizations:
- Programmatically, per application, by calling the addListeners and addInitializers methods on SpringApplication before you run it.
- Declaratively, per application, by setting the context.initializer.classes or context.listener.classes properties.
- Declaratively, for all applications, by adding a META-INF/spring.factories and packaging a jar file that the applications all use as a library.
The SpringApplication sends some special ApplicationEvents to the listeners (some even before the context is created) and then registers the listeners for events published by the ApplicationContext as well. 

It is also possible to customize the Environment before the application context is refreshed by using EnvironmentPostProcessor. Each implementation should be registered in META-INF/spring.factories, as shown in the following example:
org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor

While using @PropertySource on your @SpringBootApplication may seem to be a convenient and easy way to load a custom resource in the Environment, we do not recommend it, because Spring Boot prepares the Environment before the ApplicationContext is refreshed. Any key defined with @PropertySource is loaded too late to have any effect on auto-configuration.

Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Properties are considered in the following order:
1. Devtools global settings properties on your home directory (~/.spring-boot-devtools.properties when devtools is active).
2. @TestPropertySource annotations on your tests.
3. @SpringBootTest#properties annotation attribute on your tests.
4. Command line arguments.
5. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).
6. ServletConfig init parameters.
7. ServletContext init parameters.
8. JNDI attributes from java:comp/env.
9. Java System properties (System.getProperties()).
10. OS environment variables.
11. A RandomValuePropertySource that has properties only in random.*.
12. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).
13. Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants).
14. Application properties outside of your packaged jar (application.properties and YAML variants).
15. Application properties packaged inside your jar (application.properties and YAML variants).
16. @PropertySource annotations on your @Configuration classes.
17. Default properties (specified by setting SpringApplication.setDefaultProperties).

The SPRING_APPLICATION_JSON properties can be supplied on the command line with an environment variable. For example, you could use the following line in a UN*X shell:

$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
In the preceding example, you end up with acme.name=test in the Spring Environment. You can also supply the JSON as spring.application.json in a System property, as shown in the following example:

$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
You can also supply the JSON by using a command line argument, as shown in the following example:

$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
You can also supply the JSON as a JNDI variable, as follows: java:comp/env/spring.application.json.

The RandomValuePropertySource is useful for injecting random values (for example, into secrets or test cases). It can produce integers, longs, uuids, or strings, as shown in the following example:
my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}

spring.config.name - change explicitly the name of the configuration file (which is application.properties by default)
spring.config.location - specify explicitly Spring Boot properities config files to be inserted into the environment. It can contain directories and filenames. It can start with classpath:/ or file:/ . Files provided by this value are used as is (literaly) and will not parse any profile-specific values. Any profile specific values will override values specified with this property. Config locations are searched in reverse order. By default, the configured locations are classpath:/,classpath:/config/,file:./,file:./config/. The resulting search order is the following:
file:./config/
file:./
classpath:/config/
classpath:/

Application Property Files
SpringApplication loads properties from application.properties files in the following locations and adds them to the Spring Environment:

1. A /config subdirectory of the current directory
2. The current directory
3. A classpath /config package
4. The classpath root

In addition to application.properties files, profile-specific properties can also be defined by using the following naming convention: application-{profile}.properties. if no profiles are explicitly activated, then properties from application-default.properties are loaded.

We can refer to previously defined variables in properties files:
app.name=MyApp
app.description=${app.name} is a Spring Boot application

The restart technology provided by Spring Boot works by using two classloaders. Classes that do not change (for example, those from third-party jars) are loaded into a base classloader. Classes that you are actively developing are loaded into a restart classloader. When the application is restarted, the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts”, since the base classloader is already available and populated.

Each release of Spring Boot provides a curated list of dependencies that it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration, as Spring Boot manages that for you. When you upgrade Spring Boot itself, these dependencies are upgraded as well in a consistent way. Each release of Spring Boot is associated with a base version of the Spring Framework. 

@EnableAutoConfiguration - This annotation tells Spring Boot to “guess” how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. Auto-configuration is designed to work well with “Starters”, but the two concepts are not directly tied. 

third party starters should not start with spring-boot, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter.

By default SpringApplication converts any command line option arguments (that is, arguments starting with "--" like --server.port=9000) to a property and adds them to the Spring Environment. 
Command line properties always take precedence over other property sources (except in tests and using Devtools global settings).
We can disable them being added to the environment in the following way:
SpringApplication.setAddCommandLineProperties(false)

YamlPropertiesFactoryBean - loads YAML as Properties class
YamlMapFactoryBean - loads YAML as a Map
YamlPropertySourceLoader - can be used to expose YAML as a PropertySource in the Spring Environment. Doing so lets you use the @Value annotation with placeholders syntax to access YAML properties

Yaml files cannot be loaded via the @PropertySource annotation. We recommend that you don’t mix profile-specific YAML files and multiple YAML documents. Stick to using only one of them.

You can specify multiple profile-specific YAML documents in a single file by using a spring.profiles key to indicate when the document applies, as shown in the following example:

server:
	address: 192.168.1.100
---
spring:
	profiles: development
server:
	address: 127.0.0.1
---
spring:
	profiles: production & eu-central
server:
	address: 192.168.1.120

In the preceding example, if the development profile is active, the server.address property is 127.0.0.1. Similarly, if the production and eu-central profiles are active, the server.address property is 192.168.1.120. If the development, production and eu-central profiles are not enabled, then the value for the property is 192.168.1.100.

Spring Boot auto-configuration heavily makes use of @ConfigurationProperties for easily configuring auto-configured beans. Similar to auto-configuration classes, @ConfigurationProperties classes available in Spring Boot are for internal use only. The properties that map to the class, which are configured via properties files, YAML files, environment variables etc., are public API but the content of the class itself is not meant to be used directly.
When using @ConfigurationProperties Getters and setters are usually mandatory, since binding is through standard Java Beans property descriptors, just like in Spring MVC. A setter may be omitted in the following cases:
Maps, as long as they are initialized, need a getter but not necessarily a setter, since they can be mutated by the binder.
Collections and arrays can be accessed either through an index (typically with YAML) or by using a single comma-separated value (properties). In the latter case, a setter is mandatory. We recommend to always add a setter for such types. If you initialize a collection, make sure it is not immutable (as in the preceding example).
If nested POJO properties are initialized, a setter is not required. If you want the binder to create the instance on the fly by using its default constructor, you need a setter.

Spring Boot uses some relaxed rules for binding Environment properties to @ConfigurationProperties beans, so there does not need to be an exact match between the Environment property name and the bean property name. 

acme.my-project.person.first-name - Kebab case, which is recommended for use in .properties and .yml files.
acme.myProject.person.firstName - Standard camel case syntax.
acme.my_project.person.first_name - Underscore notation, which is an alternative format for use in .properties and .yml files.
ACME_MYPROJECT_PERSON_FIRSTNAME - Upper case format, which is recommended when using system environment variables.

Spring Boot attempts to validate @ConfigurationProperties classes whenever they are annotated with Spring’s @Validated annotation. You can use JSR-303 javax.validation constraint annotations directly on your configuration class. 
The @Value annotations supports SpEL expressions contrary to @ConfigurationProperty. It doesn't support relaxed binding of values and meta-data support as opposed to @Value.

Spring Boot uses Commons Logging for all internal logging but leaves the underlying log implementation open. Default configurations are provided for Java Util Logging, Log4J2 and Logback. To use Logback, you need to include it and spring-jcl on the class path. In each case, loggers are pre-configured to use console output with optional file output also available.
By default, if you use the "Starters", Logbakc is used for logging. Appropriate Logback routing is also included to ensure that dependent libraries that use Java Util Logging, Commons Logging, Log4J or SLF4J all work correctly.
The default log output from Spring Boot contains the following data:
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
- Date and Time: Millisecond precision and easily sortable
- Log level: ERROR, WARN, INFO, DEBUG and TRACE
- Process ID
- A "---" separator to distinguish the start of actual log messages
- JVM Thread name - enclosed in square brackets (may be truncated for console output)
- Logger name - this is actually the source class name (often abbreviated)
- The log message
Spring Boot has a LoggingSystem abstraction that attempts to configure logging based on the content of the classpath. If Logback is available, it is the first choice.

Logback does not have a FATAL level. It is mapped to ERROR.
When the debug mode is enabled, a selection of core loggers (embedded container, Hibernate, and Spring Boot) are configured to output more information. Enabling the debug mode does not configure your application to log all messages with DEBUG level.
Alternatively, you can enable a “trace” mode by starting your application with a --trace flag (or trace=true in your application.properties). Doing so enables trace logging for a selection of core loggers (embedded container, Hibernate schema generation, and the whole Spring portfolio).
By default, Spring Boot logs only to the console and does not write log files. logging.file or logging.path need to be set so that loggers can write to files. logging.file can contain an exact location or file relative to the current directory. logging.path can contain a directory in which a spring.log file will be populated. Log files rotate when they reach 10MB and ERROR-level, WARN-level and INFO-level messages are logged by default. Size limits can be changed using the logging.file.max-size property. Previously rotated files are archived indefinitely unless the logging.file.max-history property has been set.
The logging system is initialized early in the application lifecycle. Consequently, logging properties are not found in property files loaded through @PropertySource annotations.

We can setup the logging on a per package basis in the following way:
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error
It’s also possible to set logging levels using environment variables. For example, LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG will set org.springframework.web to DEBUG.
The above approach will only work for package level logging. Since relaxed binding always converts environment variables to lowercase, it’s not possible to configure logging for an individual class in this way. If you need to configure logging for a class, you can use the APPLICATION_JSON variable.

We can set the root logging level in the following way:
logging.level.root=warn

We can group the package-level loggers into groups. For example, we can add the following Tomcat packages to a group in application.properties:
logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
From then on we can refer to that logging group in the following way:
logging.level.tomcat=DEBUG
Spring Boot includes the following pre-defined logging groups:
web -> org.springframework.core.codec, org.springframework.http, org.springframework.web
sql -> org.springframework.jdbc.core, org.hibernate.SQL

Since logging is inittialized before the ApplicationContext is created, it is not possible to control logging from @PropertySources in Spring @Configuration files. The only way to change the logging system or disable it entiery is via System properties.

Spring boot can be forced to use a specific logging system by using the org.springframework.boot.logging.LoggingSystem system property. The value should be the fully-qualified class name of a LoggingSystem implementation. You can also disable Spring Boot’s logging configuration entirely by using a value of none.

Depending on your logging system, the following files are loaded:

Logging System	Customization
Logback - logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy
Log4j2 - log4j2-spring.xml or log4j2.xml
JDK (Java Util Logging) - logging.properties
The usage of the *-spring* containing files is more preferrable because Spring has more control over the provided configs from them.

To help with the customization, some other properties are transferred from the Spring Environment to System properties:
logging.exception-conversion-word, logging.file, logging.file.max-size, logging.path, logging.pattern.console, logging.pattern.dateformat, logging.pattern.file, logging.pattern.level, PID

Profile specific configuration for Spring logging:
<springProfile name="staging">
	<!-- configuration to be enabled when the "staging" profile is active -->
</springProfile>

<springProfile name="dev | staging">
	<!-- configuration to be enabled when the "dev" or "staging" profiles are active -->
</springProfile>

<springProfile name="!production">
	<!-- configuration to be enabled when the "production" profile is not active -->
</springProfile>

The basename of the resource bundle as well as several other attributes can be configured using the spring.messages namespace, as shown in the following example:
spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false

since the application.properties and application.yml files accept Spring style placeholders (${...}), the Maven filtering is changed to use @..@ placeholders. (You can override that by setting a Maven property called resource.delimiter.)

Spring Boot supports the usage of profile-based application.yaml and application.properties files. For example application-dev.properties and application-dev.yml correspond to the dev profile.

Concerning JSON:
Jackson - auto-configuraiton for Jackson is provided and Jackson is part of spring-boot-starter-json. When Jackson is on the classpath an ObjectMapper bean is automatically configured.
Gson - Auto-configuration for Gson is provided. When Gson is on the classpath a Gson bean is automatically configured.
JSON-B - Auto-configuration for JSON-B is provided. When the JSON-B API and an implementation are on the classpath a Jsonb bean will be automatically configured. The preferred JSON-B implementation is Apache Johnzon for which dependency management is provided.

The @SpringBootApplication annotation is itself annotated with @SpringBootConfiguration; not the other way around.
@SpringBootApplication annotation is itself annotated with @ComponentScan.
@SpringBootConfiguration indicates that a class provides Spring Boot application @Configuration.
The @SpringBootApplication annotation is itself annotated with @EnableAutoConfiguration.

Using @SpringBootApplication is similar to using the combination of the following annotations:
@ComponentScan - enable @Component scan on the package where the application is located
@EnableAutoConfiguration - enable Spring Boot’s auto-configuration mechanism
@Configuration - allow to register extra beans in the context or import additional configuration classes

@JsonComponent is a valid Spring Boot annotation - Component that provides JsonSerializer and/or JsonDeserializer implementations to be registered with Jackson when JsonComponentModule is in use. Can be used to annotate JsonSerializer or JsonDeserializer implementations directly or a class that contains public static inner classes named Serializer and Deserializer that extend correspondingly JsonSerializer<SomeObject> and JsonDeserializer<SomeObject>. All @JsonComponent beans are automatically registered with Jackson.

@EntityScan - an annotation placed in the main class of a Spring Boot application that scans the packages for classes annotated with @Entity. It supports similar semantics to @ComponentScan - has basePackages (alias of the default implicit value argument) and basePackageClasses as arguments. @EnableAutoConfiguration also scans for entities. @EntityScan can be used for fine tuning of this. @EntityScan doesn't scan for beans. It scans for classes which can be managed by a specific persistence context (annotated with javax.persistence.Entity).

By default, Spring boot will enable JPA repository support and look in the package (and its sub packages) where @SpringBootApplication is located.

@SpringBootConfiguration - Indicates that a class provides Spring Boot application @Configuration. Can be used as an alternative to the Spring's standard @Configuration annotation so that configuration can be found automatically (for example in tests).
Application should only ever include one @SpringBootConfiguration and most idiomatic Spring Boot applications will inherit it from @SpringBootApplication.

JsonComponentModule - Spring Bean and Jackson Module to register JsonComponent annotated beans

Spring's security web infrastructure is based entirely on standart servlet filters. It uses a chain of filters internally, each of which has a particular purpose. It deals in HttpServletRequest and HttpServletResponse. Requests
can come from a browser, a web servive client, an HttpInvoker or an AJAX application.

The Spring Boot reference documentation says:  
     "Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.
You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes.
You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only."
 Reference
16. Auto-configuration
  *  https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#using-boot-auto-configuration

Disable a specific class from auto configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@EnableAutoConfiguration(excludeName={org.ceco.package.ConfigClass.class}) //useful for classes that are not in the classpath
spring.autoconfigure.exclude - can be used to exclude config classes with this spring property
Even though auto-configuration classes are public, the only aspect of the class that is considered public API is the name of the class which can be used for disabling the auto-configuration. 

Because Spring WebFlux does not strictly depend on the Servlet API and applications are deployed by default on an embedded Reactor Netty server, War deployment is not supported for WebFlux applications.

To produce a deployable war file from a Spring Boot application the following needs to be accomplished:
- extend SpringBootServletInitializer with thethe @SpringBootApplication annotated class and override its configure method. Doing so makes use of Spring Framework’s Servlet 3.0 support and lets you configure your application when it is launched by the servlet container.
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(Application.class);
	}
- update the packaging to war:
<packaging>war</packaging>
- ensure that the embedded servlet container does not interfere with the servlet container to which the war file is deployed. To do so, you need to mark the embedded servlet container dependency as being provided.
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-tomcat</artifactId>
	<scope>provided</scope>
</dependency>

spring-boot-starter-reactor-netty - Starter for using Reactor Netty as the embedded reactive HTTP server. this dependency is required in case we would like to use WebClient even if we'll prefer to use another application server for our application
spring-boot-starter-tomcat		  - Starter for using Tomcat as the embedded server container. Default servlet container used by spring-boot-starter-web
spring-boot-starter-undertow	  - Starter for using Undertow as the embedded servlet container. An alternative to spring-boot-starter-tomcat
spring-boot-devtools			  - Contains also JRebel instance
spring-boot-starter-security	  - works for both Spring MVC and Spring WebFlux applications

spring.http.log-request-details - log all request details (incoming request, which  handler is processing it, the response outcome etc)

DevTools are automatically disabled when running a fully packaged application.
If your application is launched from java -jar or if it is started from a special classloader, then it is considered a “production application”. 
DevToolsPropertyDefaultsPostProcessor - implements the EnvironmentPostProcessor interface. It's annotated with @Order(Ordered.LOWEST_PRECEDENCE)
If you don’t want property defaults to be applied you can set spring.devtools.add-properties to false in your application.properties.

DevTools relies on the application context’s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook (SpringApplication.setRegisterShutdownHook(false)).

spring-boot-devtools disables the caching options by default.
Cache options are usually configured by settings in your application.properties file. For example, Thymeleaf offers the spring.thymeleaf.cache property. Rather than needing to set these properties manually, the spring-boot-devtools module automatically applies sensible development-time configuration.

SpringApplication - Class that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application:
- Create an appropriate ApplicationContext instance (depending on your classpath)
- Register a CommandLinePropertySource to expose command line arguments as Spring properties
- Refresh the application context, loading all singleton beans
- Trigger any CommandLineRunner beans

The SpringApplication class automatically supports YAML as an alternative to properties whenever you have the SnakeYAML library in your classpath

This is how Spring Boot provides Spring MVC autoconfiguration and adds features on top of it:
- Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
- Support for serving static resources, including support for WebJars
- Automatic registration of Converter, GenericConverter, and Formatter beans.
- Support for HttpMessageConverters
- Automatic registration of MessageCodesResolver
- Static index.html support
- custom favicon support
- Automatic use of a ConfigurableWebBindingInitializer bean

If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.

Sensible defaults are included out of the box. For example, objects can be automatically converted to JSON (by using the Jackson library) or XML (by using the Jackson XML extension, if available, or by using JAXB if the Jackson XML extension is not available). By default, strings are encoded in UTF-8.

A Bean of type org.springframework.boot.autoconfigure.http.HttpMessageConverters can be registered through Java configuration to register additional HttpMessageConverter

By default, Spring Boot serves static content from a directory called /static (or /public or /resources or /META-INF/resources) in the classpath or from the root of the ServletContext. It uses the ResourceHttpRequestHandler from Spring MVC so that you can modify thatt behavior by adding your own WebMvcConfigurer and overriding the addResourceHandlers method.

By default, resources are mapped on /**, but you can tune that with the spring.mvc.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows:
spring.mvc.static-path-pattern=/resources/**

You can also customize the static resource locations by using the spring.resources.static-locations property (replacing the default values with a list of directory locations). The root Servlet context path, "/", is automatically added as a location as well.
In addition to the “standard” static resource locations mentioned earlier, a special case is made for Webjars content. Any resources with a path in /webjars/** are served from jar files if they are packaged in the Webjars format.

Cache busting - appending a hash at the end of the resource URL in webjars to prevent caching from the browser

Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application. Spring Boot looks for a favicon.ico in the configured static content locations and the root of the classpath (in that order). If such a file is present, it is automatically used as the favicon of the application.

Spring Boot chooses to disable suffix pattern matching by default, which means that requests like "GET /projects/spring-boot.json" won’t be matched to @GetMapping("/projects/spring-boot") mappings. This is considered as a best practice for Spring MVC applications. This feature was mainly useful in the past for HTTP clients which did not send proper "Accept" request headers; we needed to make sure to send the correct Content Type to the client. Nowadays, Content Negotiation is much more reliable.

Spring MVC uses a WebBindingInitializer to initialize a WebDataBinder for a particular request. If you create your own ConfigurableWebBindingInitializer @Bean, Spring Boot automatically configures Spring MVC to use it.

Spring Boot includes auto-configuration support for the following templating engines when using Spring MVC:

FreeMarker
Groovy
Thymeleaf
Mustache
When you use one of these templating engines with the default configuration, your templates are picked up automatically from src/main/resources/templates.

By default, Spring Boot provides an /error mapping that handles all errors in a sensible way, and it is registered as a “global” error page in the servlet container. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error view that renders the same data in HTML format (to customize it, add a View that resolves to error). To replace the default behavior completely, you can implement ErrorController and register a bean definition of that type or add a bean of type ErrorAttributes to use the existing mechanism but replace the contents.
If you want to display a custom HTML error page for a given sstatus code, you can add a file to an /error folder. For example, if you want to map a static HTML page to an 404 message you should put the file in the following path:
src/main/resources/public/error/404.html
If you would like to use a FreeMarker template it should be placed in the following place:
src/main/resources/templates/ereror/5xx.ftl

For more complex mappings, beans implementing the ErrorViewResolver intetrface can be mapped as following:
public class MyErrorViewResolver implements ErrorViewResolver {
	
	@Override
	public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
		//Use the reqeuest or status tto optionally return a ModelAndView
		return ...
	}
}

The BasicErrorController can be used as a base class for a custom ErrorController. This is particularly useful if you want to add a handler for a new content type (the default is to handle text/html specifically and provide a fallback for everything else). To do so, extend BasicErrorController, add a public method with a @RequestMapping that has a produces attribute, and create a bean of your new type.

You can also define a class annotated with @ControllerAdvice to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example:

@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

	@ExceptionHandler(YourException.class)
	@ResponseBody
	ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
		HttpStatus status = getStatus(request);
		return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
	}

	private HttpStatus getStatus(HttpServletRequest request) {
		Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
		if (statusCode == null) {
			return HttpStatus.INTERNAL_SERVER_ERROR;
		}
		return HttpStatus.valueOf(statusCode);
	}

}

If you develop a RESTful API that makes use of hypermedia, Spring Boot provides auto-configuration for Spring HATEOAS that works well with most applications. The auto-configuration replaces the need to use @EnableHypermediaSupport and registers a number of beans to ease building hypermedia-based applications, including a LinkDiscoverers (for client side support) and an ObjectMapper configured to correctly marshal responses into the desired representation. The ObjectMapper is customized by setting the various spring.jackson.* properties or, if one exists, by a Jackson2ObjectMapperBuilder bean.

You can take control of Spring HATEOAS’s configuration by using @EnableHypermediaSupport. Note that doing so disables the ObjectMapper customization described earlier.

The new feature in Spring 5.0 is the addition of the Spring WebFlux framework. Unlike Spring MVC it dows not require the Servlet API, is fully asynchronous and non-blocking and implements the Reactive Streams specification through the Reactor project. Spring WebFlux comes in two flavors: functional and annotation-based. The annotation-based one is quite close to the Spring MVC - the annotations are quite similar to the ones there.
WebFlux.fn, the functional API for WebFlux, separates the routing configuration from the actual handling of the requests, as shown in the following example:
@Configuration
public class RoutingConfiguration {

	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
		return route(GET("/\{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
				.andRoute(GET("/\{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
				.andRoute(DELETE("/\{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
	}
}
@Component
public class UserHandler {
	public Mono<ServerResponse> getUser(ServerRequest request) {
		// ...
	}
	public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
		// ...
	}
	public Mono<ServerResponse> deleteUser(ServerRequest request) {
		// ...
	}
}

You can define as many RouterFunction beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence. To get started, add the spring-boot-starter-webflux module to your application. Adding both spring-boot-starter-web and spring-boot-starter-webflux modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add spring-boot-starter-webflux to their Spring MVC application to use the reactive WebClient. You can still enforce your choice by setting the chosen application type to SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE). Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty, and Undertow. Most developers use the appropriate “Starter” to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080.

The auto-configuration adds the following features on top of Spring’s defaults:

Configuring codecs for HttpMessageReader and HttpMessageWriter instances (described later in this document).
Support for serving static resources, including support for WebJars (described later in this document).
If you want to keep Spring Boot WebFlux features and you want to add additional WebFlux configuration, you can add your own @Configuration class of type WebFluxConfigurer but without @EnableWebFlux.

If you want to take complete control of Spring WebFlux, you can add your own @Configuration annotated with @EnableWebFlux.
Spring WebFlux applications do not strictly depend on the Servlet API, so they cannot be deployed as war files and do not use the src/main/webapp directory.
Spring boot includes auto-configuration support for the following template engines:
FreeMarker, Thymeleaf, Mustache
When you use one of these templating engines with the default configuration, your templates are picked up automatically from src/main/resources/templates.
Static html files and template files can be placed at the same location as in Spring MVC to be rendered when a specific HTTP error is raised in the default configuration settings.

Spring WebFlux provides a WebFilter interface that can be implemented to filter HTTP request-response exchanges. WebFilter beans found in the application context will be automatically used to filter each exchange.

Where the order of the filters is important they can implement Ordered or be annotated with @Order. Spring Boot auto-configuration may configure web filters for you. When it does so, the orders shown in the following table will be used:

Web Filter	Order
MetricsWebFilter - Ordered.HIGHEST_PRECEDENCE + 1
WebFilterChainProxy (Spring Security) - -100
HttpTraceWebFilter - Ordered.LOWEST_PRECEDENCE - 10

public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {
	// Define constructor here
	@Override
	protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
		return RouterFunctions
				.route(aPredicate, aHandler)
				.andRoute(anotherPredicate, anotherHandler);
	}
}

Any Servlet, Filter, or servlet *Listener instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your application.properties during configuration.
By default, if the context contains only a single Servlet, it is mapped to /. In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to /*.

If convention-based mapping is not flexible enough, you can use the ServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean classes for complete control.

Spring Boot ships with many auto-configurations that may define Filter beans. Here are a few examples of Filters and their respective order (lower order value means higher precedence):
Servlet Filter	Order
OrderedCharacterEncodingFilter - Ordered.HIGHEST_PRECEDENCE
WebMvcMetricsFilter - Ordered.HIGHEST_PRECEDENCE + 1
ErrorPageFilter - Ordered.HIGHEST_PRECEDENCE + 1
HttpTraceFilter - Ordered.LOWEST_PRECEDENCE - 10

Take care when registering Filter beans since they are initialized very early in the application lifectyle. If you need to register a Filter that interacts with other beans, consider using a DelegatingFilterProxyRegistrationBean instead.

When using an embedded container, automatic registration of classes annotated with @WebServlet, @WebFilter, and @WebListener can be enabled by using @ServletComponentScan on a @Configuration class.
@ServletComponentScan has no effect in a standalone container, where the container’s built-in discovery mechanisms are used instead. 

Under the hood, Spring Boot uses a different type of ApplicationContext for embedded servlet container support. The ServletWebServerApplicationContext is a special type of WebApplicationContext that bootstraps itself by searching for a single ServletWebServerFactory bean. Usually a TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory has been auto-configured.

Common servlet settings include:
- server.port - set to 0 if you would like to use a random port
- server.address - address where the server will listen on
- server.servlet.session.persistent - wether the session is persistent
- server.servlet.session.timeout - session timeout
- server.servlet.session.store-dir - location of session data
- server.servlet.session.cookie.* - session cookie configuration
- server.error.path - location of the error path
- server.compression.enabled - enable HTTP response compression
- server.compression.min-response-size - By default, responses must be at least 2048 bytes in length for compression to be performed. This is how it can be set. By default, responses are compressed only if their content type is one of the following: text/html, text/xml, text/plain, text/css, text/javascript, application/javascript, application/json, application/xml
- server.use-forward-headers - it needs to be set to true in application.properties

Spring Boot tries as much as possible to expose common settings, but this is not always possible. For those cases, dedicated namespaces offer server-specific customizations (see server.tomcat and server.undertow). For instance, access logs can be configured with specific features of the embedded servlet container.

Programmatic customization:

import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

	@Override
	public void customize(ConfigurableServletWebServerFactory server) {
		server.setPort(9000);
	}

}

TomcatServletWebServerFactory, JettyServletWebServerFactory and UndertowServletWebServerFactory are dedicated variants of ConfigurableServletWebServerFactory that have additional customization setter methods for Tomcat, Jetty and Undertow respectively. ConfigurableServletWebServerFactory bean can also be set with the @Bean annotation.

org.springframework.boot.autoconfigure.web.ServerProperties - a class annotated with configuration properties declaring the values starting with "server.*"
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)

Undertow does not support JSPs.
simply creating a custom error.jsp page does not override the default view for error handling. Custom error pages should be used instead.

@ServerEndpoint - This class level annotation declares that the class it decorates is a web socket endpoint that will be deployed and made available in the URI-space of a web socket server.
If you want to use @ServerEndpoint in a Spring Boot application that used an embedded container, you must declare a single ServerEndpointExporter @Bean.

Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty and Undertow. By default, the embedded server listens for HTTP requests on port 8080.

When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: ReactorResourceFactory or JettyResourceFactory.

By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given:

the same technology is used for server and client
the client instance is built using the WebClient.Builder bean auto-configured by Spring Boot
Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom ReactorResourceFactory or JettyResourceFactory bean - this will be applied to both clients and servers.

If Spring Security is on the classpath, then web applications are secured by default. Spring Boot relies on Spring Security’s content-negotiation strategy to determine whether to use httpBasic or formLogin. To add method-level security to a web application, you can also add @EnableGlobalMethodSecurity with your desired settings. 
The default UserDetailsService has a single user. The user name is user, and the password is random and is printed at INFO level when the application starts

The basic features you get by default in a web application when using Spring Boot are:
- A UserDetailsService (or ReactiveUserDetailsService in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see SecurityProperties.User for the properties of the user).
Form-based login or HTTP Basic security (depending on the Accept header in the request) for the entire application (including actuator endpoints if actuator is on the classpath).
- A DefaultAuthenticationEventPublisher for publishing authentication events.
For security purposes, all actuators other than /health and /info are disabled by default. The management.endpoints.web.exposure.include property can be used to enable the actuators. If Spring Security is on the classpath and no other WebSecurityConfigurerAdapter is present, all actuators other than /health and /info are secured by Spring Boot auto-configuration. If you define a custom WebSecurityConfigurerAdapter, Spring Boot auto-configuration will back of and you will be in full control of actuator access rules.

Cross Site request forgery protection in Spring Boot Actuator - Since Spring Boot relies on Spring Security’s defaults, CSRF protection is turned on by default. This means that the actuator endpoints that require a POST (shutdown and loggers endpoints), PUT or DELETE will get a 403 forbidden error when the default security configuration is in use.

The default security configuration is implemented in SecurityAutoConfiguration and UserDetailsServiceAutoConfiguration. SecurityAutoConfiguration imports SpringBootWebSecurityConfiguration for web security and UserDetailsServiceAutoConfiguration configures authentication, which is also relevant in non-web applications. To switch off the default web application security configuration completely, you can add a bean of type WebSecurityConfigurerAdapter (doing so does not disable the UserDetailsService configuration or Actuator’s security).
To also switch off the UserDetailsService configuration, you can add a bean of type UserDetailsService, AuthenticationProvider, or AuthenticationManager. There are several secure applications in the Spring Boot samples to get you started with common use cases.
Access rules can be overridden by adding a custom WebSecurityConfigurerAdapter. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. EndpointRequest can be used to create a RequestMatcher that is based on the management.endpoints.web.base-path property. PathRequest can be used to create a RequestMatcher for resources in commonly used locations.

Similar to Spring MVC applications, you can secure your WebFlux applications by adding the spring-boot-starter-security dependency. The default security configuration is implemented in ReactiveSecurityAutoConfiguration and UserDetailsServiceAutoConfiguration. ReactiveSecurityAutoConfiguration imports WebFluxSecurityConfiguration for web security and UserDetailsServiceAutoConfiguration configures authentication, which is also relevant in non-web applications. To switch off the default web application security configuration completely, you can add a bean of type WebFilterChainProxy (doing so does not disable the UserDetailsService configuration or Actuator’s security).
To also switch off the UserDetailsService configuration, you can add a bean of type ReactiveUserDetailsService or ReactiveAuthenticationManager.
Access rules can be configured by adding a custom SecurityWebFilterChain. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. EndpointRequest can be used to create a ServerWebExchangeMatcher that is based on the management.endpoints.web.base-path property.
PathRequest can be used to create a ServerWebExchangeMatcher for resources in commonly used locations.

@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	return http
		.authorizeExchange()
			.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
			.pathMatchers("/foo", "/bar")
				.authenticated().and()
			.formLogin().and()
		.build();
}

Spring Boot can auto-configure embedded H2, HSQL, and Derby databases. You need not provide any connection URLs. You need only include a build dependency to the embedded database that you want to use.
If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use. If you want to make sure that each context has a separate embedded database, you should set spring.datasource.generate-unique-name to true.
You need a dependency on spring-jdbc for an embedded database to be auto-configured. In this example, it is pulled in transitively through spring-boot-starter-data-jpa.

Production database connections can also be auto-configured by using a pooling DataSource. Spring Boot uses the following algorithm for choosing a specific implementation:

1. We prefer HikariCP for its performance and concurrency. If HikariCP is available, we always choose it.
2. Otherwise, if the Tomcat pooling DataSource is available, we use it.
3. If neither HikariCP nor the Tomcat pooling datasource are available and if Commons DBCP2 is available, we use it.
4. If you use the spring-boot-starter-jdbc or spring-boot-starter-data-jpa “starters”, you automatically get a dependency to HikariCP.
You can bypass that algorithm completely and specify the connection pool to use by setting the spring.datasource.type property. This is especially important if you run your application in a Tomcat container, as tomcat-jdbc is provided by default.

Additional connection pools can always be configured manually. If you define your own DataSource bean, auto-configuration does not occur.
You can bypass that algorithm completely and specify the connection pool to use by setting the spring.datasource.type property. This is especially important if you run your application in a Tomcat container, as tomcat-jdbc is provided by default.
Additional connection pools can always be configured manually. If you define your own DataSource bean, auto-configuration does not occur.

DataSource configuration is controlled by external configuration properties in spring.datasource.*. For example, you might declare the following section in application.properties:

spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
You should at least specify the URL by setting the spring.datasource.url property. Otherwise, Spring Boot tries to auto-configure an embedded database.
You often do not need to specify the driver-class-name, since Spring Boot can deduce it for most databases from the url.
For a pooling DataSource to be created, we need to be able to verify that a valid Driver class is available, so we check for that before doing anything. In other words, if you set spring.datasource.driver-class-name=com.mysql.jdbc.Driver, then that class has to be loadable.

It is also possible to fine tune implementation-specific settings by using their respective prefix (spring.datasource.hikari.*, spring.datasource.tomcat.* and spring.datasource.dbcp2.*)

The spring.datasource.jndi-name property can be used as an alternative to the spring.datasource.url, spring.datasource.username, and spring.datasource.password
 properties to access the DataSource from a specific JNDI location. For example, the following section in application.properties shows how you can access a JBoss AS defined DataSource:
spring.datasource.jndi-name=java:jboss/datasources/customers

The spring-boot-starter-data-jpa POM provides a quick way to get started. It provides the following key dependencies:

Hibernate: One of the most popular JPA implementations.
Spring Data JPA: Makes it easy to implement JPA-based repositories.
Spring ORMs: Core ORM support from the Spring Framework.

Traditionally, JPA “Entity” classes are specified in a persistence.xml file. With Spring Boot, this file is not necessary and “Entity Scanning” is used instead. By default, all packages below your main configuration class (the one annotated with @EnableAutoConfiguration or @SpringBootApplication) are searched. Any classes annotated with @Entity, @Embeddable, or @MappedSuperclass are considered.

Spring Data JPA repositories are interfaces that you can define to access data. JPA queries are created automatically from your method names. For example, a CityRepository interface might declare a findAllByState(String state) method to find all the cities in a given state.
For more complex queries, you can annotate your method with Spring Data’s Query annotation.
epring Data repositories usually extend from the Repository or CrudRepository interfaces. If you use auto-configuration, repositories are searched from the package containing your main configuration class (the one annotated with @EnableAutoConfiguration or @SpringBootApplication) down.
When extending CrudRepositories if you want to be selective about which CRUD methods to expose to your new interface you can explicitly re-declare those methods in your new interface.

Spring Data JPA repositories support three different modes of bootstrapping: default, deferred, and lazy. To enable deferred or lazy bootstrapping in a Spring Boot application, set the spring.data.jpa.repositories.bootstrap-mode to deferred or lazy respectively. When using deferred or lazy bootstrapping, the auto-configured EntityManagerFactoryBuilder will use the context’s AsyncTaskExecutor, if any, as the bootstrap executor. If more than one exists, the one named applicationTaskExecutor will be used.

By default, JPA databases are automatically created only if you use an embedded database (H2, HSQL, or Derby). Otherwise, to create and drop tables you can add the following line to your application.properties:
spring.jpa.hibernate.ddl-auto=create-drop

Spring boot and JDBC:
Spring Data includes repository support for JDBC and will automatically generate SQL for the methods on CrudRepository. For more advanced queries, a @Query annotation is provided.
Spring Boot will auto-configure Spring Data’s JDBC repositories when the necessary dependencies are on the classpath. They can be added to your project with a single dependency on spring-boot-starter-data-jdbc. If necessary, you can take control of Spring Data JDBC’s configuration by adding the @EnableJdbcRepositories annotation or a JdbcConfiguration subclass to your application.

If you are running a web application, Spring Boot by default registers OpenEntityManagerInViewInterceptor to apply the “Open EntityManager in View” pattern, to allow for lazy loading in web views. If you do not want this behavior, you should set spring.jpa.open-in-view to false in your application.properties.

Disable web server in case there are Spring WebFlux or Spring MVC dependencies in classpath:
spring.main.web-application-type=none

WebMvcAutoConfiguration adds the following ViewResolvers to the Spring Boot application context:
- An InternalResourceViewResolver named ‘defaultViewResolver’. This one locates physical resources that can be rendered by using the DefaultServlet (including static resources and JSP pages, if you use those). It applies a prefix and a suffix to the view name and then looks for a physical resource with that path in the servlet context (the defaults are both empty but are accessible for external configuration through spring.mvc.view.prefix and spring.mvc.view.suffix). You can override it by providing a bean of the same type.
- A BeanNameViewResolver named ‘beanNameViewResolver’. This is a useful member of the view resolver chain and picks up any beans with the same name as the View being resolved. It should not be necessary to override or replace it.
- A ContentNegotiatingViewResolver named ‘viewResolver’ is added only if there are actually beans of type View present. This is a ‘master’ resolver, delegating to all the others and attempting to find a match to the ‘Accept’ HTTP header sent by the client. There is a useful blog about ContentNegotiatingViewResolver that you might like to study to learn more, and you might also look at the source code for detail. You can switch off the auto-configured ContentNegotiatingViewResolver by defining a bean named ‘viewResolver’.
- If you use Thymeleaf, you also have a ThymeleafViewResolver named ‘thymeleafViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.thymeleaf.prefix, and the suffix is spring.thymeleaf.suffix. The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.html’, respectively. You can override ThymeleafViewResolver by providing a bean of the same name.
- If you use FreeMarker, you also have a FreeMarkerViewResolver named ‘freeMarkerViewResolver’. It looks for resources in a loader path (which is externalized to spring.freemarker.templateLoaderPath and has a default value of ‘classpath:/templates/’) by surrounding the view name with a prefix and a suffix. The prefix is externalized to spring.freemarker.prefix, and the suffix is externalized to spring.freemarker.suffix. The default values of the prefix and suffix are empty and ‘.ftl’, respectively. You can override FreeMarkerViewResolver by providing a bean of the same name.
- If you use Groovy templates (actually, if groovy-templates is on your classpath), you also have a GroovyMarkupViewResolver named ‘groovyMarkupViewResolver’. It looks for resources in a loader path by surrounding the view name with a prefix and suffix (externalized to spring.groovy.template.prefix and spring.groovy.template.suffix). The prefix and suffix have default values of ‘classpath:/templates/’ and ‘.tpl’, respectively. You can override GroovyMarkupViewResolver by providing a bean of the same name.

As described in Section 35.1, “RestTemplate Customization”, you can use a RestTemplateCustomizer with RestTemplateBuilder to build a customized RestTemplate. This is the recommended approach for creating a RestTemplate configured to use a proxy.

static class ProxyCustomizer implements RestTemplateCustomizer {
	@Override
	public void customize(RestTemplate restTemplate) {
		HttpHost proxy = new HttpHost("proxy.example.com");
		HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {
			@Override
			public HttpHost determineProxy(HttpHost target, HttpRequest request, HttpContext context)
					throws HttpException {
				if (target.getHostName().equals("192.168.0.5")) {
					return null;
				}
				return super.determineProxy(target, request, context);
			}
		}).build();
		restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
	}
}

To configure your own DataSource, define a @Bean of that type in your configuration.
@Bean
@ConfigurationProperties(prefix="app.datasource")
public DataSource dataSource() {
	return new FancyDataSource();
	// or: return DataSourceBuilder.create().build();
	// or: return DataSourceBuilder.create().type(HikariDataSource.class).build();
}

Here's the corresponding example configs for this prefix:
app.datasource.url=jdbc:h2:mem:mydb
app.datasource.username=sa
app.datasource.pool-size=30
Assuming that your FancyDataSource has regular JavaBean properties for the URL, the username, and the pool size, these settings are bound automatically before the DataSource is made available to other components.

A bean for the data source properties can be defined:
@Bean
@Primary
@ConfigurationProperties("app.datasource")
public DataSourceProperties dataSourceProperties() {
	return new DataSourceProperties();
}

DataSourceProperties - this is a Spring Boot type which represents data source configs.
(new DataSourceProperties()).initializeDataSourceBuilder().type(HikariDataSource.class).build();

To take full control of the configuration of the EntityManagerFactory, you need to add a @Bean named ‘entityManagerFactory’. Spring Boot auto-configuration switches off its entity manager in the presence of a bean of that type.

Hibernate uses two different naming strategies to map names from the object model to the corresponding database names. The fully qualified class name of the physical and the implicit strategy implementations can be configured by setting the spring.jpa.hibernate.naming.physical-strategy and spring.jpa.hibernate.naming.implicit-strategy properties, respectively. Alternatively, if ImplicitNamingStrategy or PhysicalNamingStrategy beans are available in the application context, Hibernate will be automatically configured to use them.

@EnableJpaRepositories - Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data repositories by default. We need to autowire a bean which is of type EntityManagerFactory also in the @Configuration

@Configuration
@EnableJpaRepositories(basePackageClasses = Customer.class,
		entityManagerFactoryRef = "customerEntityManagerFactory")
public class CustomerConfiguration {
	...
}

To make an already exiting application a Spring Boot application the following needs to be done:
- add @SpringBootApplication to the main class
- extend the main class with SpringBootServletInitializer
- Static resources can be moved to /public (or /static or /resources or /META-INF/resources) in the classpath root. The same applies to messages.properties
- An ApplicationContext in an XML file can be added through an @ImportResource in your Application.
- Vanilla usage of Spring DispatcherServlet and Spring Security should require no further changes.

This Maven setting for the Spring Boot plugin generates build info which will populate the BuildProperties.
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
<executions>
	<execution>
		<goals>
			<goal>build-info</goal>
		</goals>
	</execution>
</executions>

To Creating a custom Spring Boot starter:
1. An auto-configure class for our library along with a properties class for custom configuration.
2. A starter pom to bring in the dependencies of the library and the autoconfigure project.
The starter pom should have the following dependency:
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
            <version>${spring-boot.version}</version>
        </dependency>
- Spring Boot checks for the presence of a META-INF/spring.factories file within your published jar. The file should list your configuration classes under the EnableAutoConfiguration key, as shown in the following example:
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration
This file maps a name to different configuration classes which Spring Boot will try to run. Whether or not these classes will actually run will depend on the presence of dependent classes on the classpath. For example, if the classes for MongoDB are found on the classpath, MongoAutoConfiguration will run and all the mongo related beans will be initialized.
This conditional initialization is enabled by the @ConditionalOnClass annotation. E.g.
@ConditionalOnClass(MongoClient.class) 
public class MongoAutoConfiguration { ... }
if the MongoClient is available in the classpath - this configuration class will run populating the Spring bean factory with a MongoClient iniialized with default config settings
- custom properties from the application.properties file
@Configuration
@ConditionalOnClass(MongoClient.class)
@EnableConfigurationProperties(MongoProperties.class)
@ConditionalOnMissingBean(type = "org.springframework.data.mongodb.MongoDbFactory")
public class MongoAutoConfiguration {
    // configuration code
}
@EnableConfigurationProperties annotation is declared with the MongoProperties class which acts as the container for custom properties:
@ConfigurationPropertites(prefix = "spring.data.mongodb")
public class MongoProperties {
	private String host; //this corresponds to spring.data.mongodb.host
}


-- Spring Boot Testing

spring-boot-starter-test - initial dependency artifact for unit testing in Spring Boot. provides the Spring test context framework, MockMvc and Serlet API 3 mocks and other utilities.
spring-boot-test-autoconfigure - The spring-boot-test-autoconfigure module includes a number of annotations that can be used to automatically configure only "slices" of an application (e.g. only the web layer, only the persistence layere and so forth). Each of them works in a similar way, providing a @...Test annotation that loads the ApplicationContext and one or more @AutoConfigure... annotations that can be used to customize auto-configuration settings.

The spring-boot-starter-test “Starter” (in the test scope) contains the following provided libraries:

JUnit 4: The de-facto standard for unit testing Java applications.
Spring Test & Spring Boot Test: Utilities and integration test support for Spring Boot applications.
AssertJ: A fluent assertion library.
Hamcrest: A library of matcher objects (also known as constraints or predicates).
Mockito: A Java mocking framework.
JSONassert: An assertion library for JSON.
JsonPath: XPath for JSON.

Spring Boot provides a @SpringBootTest annotation which can be used as an alternative to the standard spring-test @ContextConfiguration annotation when you need Spring Boot features. The annotation works by creating the ApplicationContext for your tests through SpringApplication.
You can use the webEnvironment attribute of @SpringBootTest to further refine how you run tests:
- MOCK(Default) - loads a web ApplicationContext and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not found in the classpath it falls back to NONE's behavior and creates an non-web ApplicationContext. It can be used in conjunction with @AutoConfigureMockMvc and @AutoConfigureWebTestClient
- RANDOM_PORT - loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a random port
- DEFINED_PORT - loads a WebServerApplicationContext and provides a real web environment. It's port is read from server.port or 8080 by default
- NONE - Loads an ApplicationContext by using SpringApplication but does not provide any web environment
By default, @Transactional runs each method in a transaction and rolls back the changes after the method. However, as using this arrangement with either RANDOM_PORT or DEFINED_PORT implicitly provides a real servlet environment, the HTTP client and server run in separate threads and, thus, in separate transactions. Any transaction initiated on the server does not roll back in this case.
If Spring MVC is available, a regular MVC-based application context is configured. If you have only Spring WebFlux, we’ll detect that and configure a WebFlux-based application context instead.
If both are present, Spring MVC takes precedence. If you want to test a reactive web application in this scenario, you must set the spring.main.web-application-type property:
@SpringBootTest(properties = "spring.main.web-application-type=reactive")
@ComponentScan(excludeFilters = @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class))

If you are using JUnit 4, don’t forget to also add @RunWith(SpringRunner.class) to your test, otherwise the annotations will be ignored. If you are using JUnit 5, there’s no need to add the equivalent @ExtendWith(SpringExtension.class) as @SpringBootTest and the other @…Test annotations are already annotated with it.

@WebIntegrationTest - annotation for writing full end-to-end integration tests

If you are using embedded in-memory databases in your test, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use. If you want to make sure that each context has a separate embedded database, you should set spring.datasource.generate-unique-name to true.

@DataJpaTest provides some standard setup needed for ttesting the persistence layer:
- configuring H@, an in-memory database
- setting Hibernate, Spring Data and the DataSource
- performing an @EntityScan
- turning on SQL logging

@TestConfiguration - @Configuration that can be used to define additional beans or customizations for a test. Unlike regular @Configuration classes the use of @TestConfiguration does not prevent auto-detection of @SpringBootConfiguration. It can be placed on an inner class of a test to cutomize the primary configuration. When placed on a top-level class, @TestConfiguration indicates that classes in src/test/java should not be picked up by scanning. You can then import that class explicitly where it is required with the @Import annotation:
@RunWith(SpringRunner.class)
@SpringBootTest
@Import(MyTestsConfiguration.class)
public class MyTests {
	@Test
	public void exampleTest() {
	...
	}
}

By default, @SpringBootTest does not start the server. If you have web endpoints that you want to test against this mock environment, you can additionally configure MockMvc by autowiring a property with type MockMvc and annotating the test with @AutoConfigureMockMvc

We can configure in a similar fashion a WebTestClient to test out asynchronous WebClient calls - annotate the test with @AutoConfigureWebTestClient. This requires Spring WebFlux in the class path.
@LocalServerPort - can be annotated on an int or Integer property to inject the actual port value used in an integration test with an actual web server. This is a meta-annotation for @Value("${local.server.port}")

Spring Boot provides the @MockBean annotation that can be used to define a Mockito mock for a bean inside the test's application context. This annotation can be used to add new beans or replace existing ones.
The annotation ca be used directly on test classes, on fields within a test, or on @Configuration classes and fields.
When used on a field, the instance of the created mock is also injected.
Mocked beans are automatically reset after each test method.
@MockBean cannot be used to mock the behavior of a bean that’s exercised during application context refresh. 
Additionally, you can use @SpyBean to wrap any existing bean with a Mockito spy.

Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes. If you need to exclude one of them, most @...Test annotations provide an excludeAutoConfiguration attribute. Alternatively, you can use @ImportAutoConfiguration#exclude.
Including multiple “slices” by using several @...Test annotations in one test is not supported. If you need multiple “slices”, pick one of the @...Test annotations and include the @AutoConfigure... annotations of the other “slices” by hand.
It is also possible to use the @AutoConfigure... annotations with the standard @SpringBootTest annotation. You can use this combination if you are not interested in “slicing” your application but you want some of the auto-configured test beans.

To test that object JSON serialization and deserialization is working as expected, you can use the @JsonTest annotation. @JsonTest auto-configures the available supported JSON mapper, which can be one of the following libraries:

Jackson ObjectMapper, any @JsonComponent beans and any Jackson Modules
Gson
Jsonb
If you need to configure elements of the auto-configuration, you can use the @AutoConfigureJsonTesters annotation.
Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected. The JacksonTester, GsonTester, JsonbTester, and BasicJsonTester classes can be used for Jackson, Gson, Jsonb, and Strings respectively. Any helper fields on the test class can be @Autowired when using @JsonTest. 

@RunWith(SpringRunner.class)
@JsonTest
public class MyJsonTests {

	@Autowired
	private JacksonTester<VehicleDetails> json;

	@Test
	public void testSerialize() throws Exception {
		VehicleDetails details = new VehicleDetails("Honda", "Civic");
		// Assert against a `.json` file in the same package as the test
		assertThat(this.json.write(details)).isEqualToJson("expected.json");
		// Or use JSON path based assertions
		assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
		assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
				.isEqualTo("Honda");
	}

	@Test
	public void testDeserialize() throws Exception {
		String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
		assertThat(this.json.parse(content))
				.isEqualTo(new VehicleDetails("Ford", "Focus"));
		assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
	}

}

To test whether Spring MVC controllers are working as expected, use the @WebMvcTest annotation. @WebMvcTest auto-configures the Spring MVC infrastructure and limits scanned beans to @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter, Filter, WebMvcConfigurer, and HandlerMethodArgumentResolver.
If you need to register extra components, such as the Jackson Module, you can import additional configuration classes by using @Import on your test

Often, @WebMvcTest is limited to a single controller and is used in combination with @MockBean to provide mock implementations for required collaborators.
@WebMvcTest also auto-configures MockMvc. Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.
@AutoConfiguerMockMvc - can be useful to configure MockMvc in a non-@WebMvcTest
@WebMvcTest(UserVehicleController.class)

By default, Spring Boot puts WebDriver beans in a special “scope” to ensure that the driver exits after each test and that a new instance is injected. If you do not want this behavior, you can add @Scope("singleton") to your WebDriver @Bean definition. The webDriver scope created by Spring Boot will replace any user defined scope of the same name. If you define your own webDriver scope you may find it stops working when you use @WebMvcTest.

If you have Spring Security on the classpath, @WebMvcTest will also scan WebSecurityConfigurer beans.

You can use @DataJpaTesst annotation to test JPA applications. By default, it scans for @Entity classes and configures Spring Data JPA repositories. By default, @DataJpaTests are transactional and roll back at the end of each test.
They can be disabled in the following way:
@Transactional(propagation = Propagation.NOT_SUPPORTED)
Data JPA tests may also inject a TestEntityManager bean, which provides an alternative to the standard JPA EntityManager that is specifically designed for tests. If you want to use TestEntityManager outside of @DataJpaTest instances, you can also use the @AutoConfigureTestEntityManager annotation. A JdbcTemplate is also available if you need that. 

	@Autowired
	private TestEntityManager entityManager;

@DataJpaTest uses an in-memory database. In-memory databases run well for tests since they are fast and do not require any installation. if, however, you preefer to rrun tests against a real database you can use the @AutoConfigureTestDatabase annotation:
@AutoConfigureTestDatabase(replace=Replace.NONE)

@JdbcTest is similar to @DataJpaTest but is for tests that only require a DataSource and do not use Spring Data JDBC. By default, it configures an in-memory embedded database and a JdbcTemplate. Regular @Component beans are not loaded into the ApplicationContext.By default, JDBC tests are transactional and roll back at the end of each test. This behavior of transactions can be disabled in the following way:
@Transactional(propagation = Propagation.NOT_SUPPORTED)
If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for DataJpaTest.

You can use the @RestClientTest annotation to test REST clients. By default, it auto-configures Jackson, GSON, and Jsonb support, configures a RestTemplateBuilder, and adds support for MockRestServiceServer. Regular @Component beans are not loaded into the ApplicationContext. Regular @Component beans are not loaded into the ApplicationContext.

@RestClientTest - Annotation that can be used in combination with @RunWith(SpringRunner.class) for a typical Spring rest client test. Can be used when a test focuses only on beans that use RestTemplateBuilder.  It auto-configures different dependencies like Jackson, GSON, and Jsonb support, configures a RestTemplateBuilder
Using this annotation will disable full auto-configuration and instead apply only configuration relevant to rest client tests (i.e. Jackson or GSON auto-configuration and @JsonComponent beans, but not regular @Component beans).
By default, tests annotated with RestClientTest will also auto-configure a MockRestServiceServer. For more fine-grained control the @AutoConfigureMockRestServiceServer annotation can be used.
If you are testing a bean that doesn't use RestTemplateBuilder but instead injects a RestTemplate directly, you can add @AutoConfigureWebClient(registerRestTemplate=true).

Each slice provides one or more @AutoConfigure... annotations that namely defines the auto-configurations that should be included as part of a slice. Additional auto-configurations can be added by creating a custom @AutoConfigure... annotation or simply by adding @ImportAutoConfiguration to the test as shown in the following example:

@RunWith(SpringRunner.class)
@JdbcTest
@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
public class ExampleJdbcTests {

}
In such cases the regular @Import annotation shouldn't be used as it's being handled in a different manner by Spring Boot.

If you structure your code in a sensible way, your @SpringBootApplication class is used by default as the configuration of your tests.

Test utilities:
A few test utility classes that are generally useful when testing your application are packaged as part of Spring Boot.
- ConfigFileApplicationContextInitializer
ConfigFileApplicationContextInitializer is an ApplicationContextInitializer that you can apply to your tests to load Spring Boot application.properties files. You can use it when you do not need the full set of features provided by @SpringBootTest, as shown in the following example:
@ContextConfiguration(classes = Config.class,
	initializers = ConfigFileApplicationContextInitializer.class)

Using ConfigFileApplicationContextInitializer alone does not provide support for @Value("${...}") injection. Its only job is to ensure that application.properties files are loaded into Spring’s Environment. For @Value support, you need to either additionally configure a PropertySourcesPlaceholderConfigurer or use @SpringBootTest, which auto-configures one for you.

- TestPropertyValues
TestPropertyValues lets you quickly add properties to a ConfigurableEnvironment or ConfigurableApplicationContext. You can call it with key=value strings, as follows:
TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);
- OutputCapture
OutputCapture is a JUnit Rule that you can use to capture System.out and System.err output. You can declare the capture as a @Rule and then use toString() for assertions, as follows:

	@Rule
	public final OutputCapture capture = new OutputCapture();

	@Test
	public void testName() {
		System.out.println("Hello World!");
		assertThat(this.capture.toString()).contains("World");
	}

- TestRestTemplate
TestRestTemplate is a convenience alternative to Spring’s RestTemplate that is useful in integration tests.

It is recommended, but not mandatory, to use the Apache HTTP Client (version 4.3.2 or better). If you have that on your classpath, the TestRestTemplate responds by configuring the client appropriately. If you do use Apache’s HTTP client, some additional test-friendly features are enabled:

Redirects are not followed (so you can assert the response location).
Cookies are ignored (so the template is stateless).

Spring Framework 5.0 provides a new WebTestClient that works for WebFlux integration tests and both WebFlux and MVC end-to-end testing. It provides a fluent API for assertions, unlike TestRestTemplate.

Spring Security provides support for running tests as a specific user. For example, the test in the snippet below will run with an authenticated user that has the ADMIN role.

@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
	mvc
		.perform(get("/"))
		...
}

